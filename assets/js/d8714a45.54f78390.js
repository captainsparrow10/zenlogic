"use strict";(globalThis.webpackChunkerp_docs=globalThis.webpackChunkerp_docs||[]).push([[3695],{5651:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>_,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"microservicios/inventory-service/grpc-server","title":"gRPC Server - Inventory Service","description":"Definici\xf3n completa del servidor gRPC del Inventory Service para comunicaci\xf3n s\xedncrona con otros servicios.","source":"@site/docs/02-microservicios/inventory-service/07-grpc-server.md","sourceDirName":"02-microservicios/inventory-service","slug":"/microservicios/inventory-service/grpc-server","permalink":"/zenlogic/microservicios/inventory-service/grpc-server","draft":false,"unlisted":false,"editUrl":"https://github.com/your-repo/edit/main/docs/02-microservicios/inventory-service/07-grpc-server.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7}}');var r=t(4848),s=t(8453);const a={sidebar_position:7},o="gRPC Server - Inventory Service",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Puerto gRPC",id:"puerto-grpc",level:2},{value:"Proto File Definition",id:"proto-file-definition",level:2},{value:"Implementaci\xf3n del Servidor",id:"implementaci\xf3n-del-servidor",level:2},{value:"Server Setup",id:"server-setup",level:3},{value:"Service Implementation",id:"service-implementation",level:3},{value:"Ejemplos de Uso desde Order Service",id:"ejemplos-de-uso-desde-order-service",level:2},{value:"Python Client",id:"python-client",level:3},{value:"Manejo de Errores",id:"manejo-de-errores",level:2},{value:"Error Codes",id:"error-codes",level:3},{value:"Retry Strategy",id:"retry-strategy",level:3},{value:"Circuit Breaker",id:"circuit-breaker",level:2},{value:"Health Check",id:"health-check",level:2},{value:"Pr\xf3ximos Pasos",id:"pr\xf3ximos-pasos",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"grpc-server---inventory-service",children:"gRPC Server - Inventory Service"})}),"\n",(0,r.jsx)(n.p,{children:"Definici\xf3n completa del servidor gRPC del Inventory Service para comunicaci\xf3n s\xedncrona con otros servicios."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"El Inventory Service expone los siguientes m\xe9todos gRPC para que Order Service pueda:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Verificar disponibilidad de stock"}),"\n",(0,r.jsx)(n.li,{children:"Reservar stock temporalmente"}),"\n",(0,r.jsx)(n.li,{children:"Confirmar reservas (cuando el pago es exitoso)"}),"\n",(0,r.jsx)(n.li,{children:"Liberar reservas (cuando el pago falla o timeout)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"puerto-grpc",children:"Puerto gRPC"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"GRPC_PORT=50053\n"})}),"\n",(0,r.jsx)(n.h2,{id:"proto-file-definition",children:"Proto File Definition"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-protobuf",children:'syntax = "proto3";\n\npackage inventory.v1;\n\n// Inventory Service\nservice InventoryService {\n    // Verifica disponibilidad de stock\n    rpc CheckAvailability(CheckAvailabilityRequest) returns (CheckAvailabilityResponse);\n\n    // Verifica disponibilidad de m\xfaltiples variantes\n    rpc CheckBulkAvailability(CheckBulkAvailabilityRequest) returns (CheckBulkAvailabilityResponse);\n\n    // Reserva stock temporalmente\n    rpc ReserveStock(ReserveStockRequest) returns (ReserveStockResponse);\n\n    // Confirma una reserva (pago exitoso)\n    rpc ConfirmReservation(ConfirmReservationRequest) returns (ConfirmReservationResponse);\n\n    // Libera una reserva (pago fallido o timeout)\n    rpc ReleaseReservation(ReleaseReservationRequest) returns (ReleaseReservationResponse);\n\n    // Obtiene informaci\xf3n de stock\n    rpc GetStockInfo(GetStockInfoRequest) returns (GetStockInfoResponse);\n}\n\n// ==================== Check Availability ====================\n\nmessage CheckAvailabilityRequest {\n    string organization_id = 1;\n    string variant_id = 2;\n    string warehouse_id = 3;  // Opcional, si no se env\xeda verifica en todos los warehouses\n    int32 quantity = 4;\n}\n\nmessage CheckAvailabilityResponse {\n    bool available = 1;\n    int32 available_quantity = 2;\n    string warehouse_id = 3;\n    string message = 4;\n}\n\n// ==================== Check Bulk Availability ====================\n\nmessage CheckBulkAvailabilityRequest {\n    string organization_id = 1;\n    repeated AvailabilityItem items = 2;\n}\n\nmessage AvailabilityItem {\n    string variant_id = 1;\n    string warehouse_id = 2;  // Opcional\n    int32 quantity = 3;\n}\n\nmessage CheckBulkAvailabilityResponse {\n    bool all_available = 1;\n    repeated AvailabilityResult results = 2;\n}\n\nmessage AvailabilityResult {\n    string variant_id = 1;\n    string warehouse_id = 2;\n    bool available = 3;\n    int32 available_quantity = 4;\n    int32 requested_quantity = 5;\n    string message = 6;\n}\n\n// ==================== Reserve Stock ====================\n\nmessage ReserveStockRequest {\n    string organization_id = 1;\n    string order_id = 2;\n    repeated ReservationItem items = 3;\n    int32 ttl_minutes = 4;  // Tiempo de vida de la reserva (default: 15)\n}\n\nmessage ReservationItem {\n    string variant_id = 1;\n    string warehouse_id = 2;  // Preferido, si no se especifica se elige autom\xe1ticamente\n    int32 quantity = 3;\n}\n\nmessage ReserveStockResponse {\n    bool success = 1;\n    string reservation_id = 2;\n    repeated ReservedItem reserved_items = 3;\n    string expires_at = 4;  // ISO 8601 timestamp\n    string message = 5;\n}\n\nmessage ReservedItem {\n    string reservation_item_id = 1;\n    string variant_id = 2;\n    string warehouse_id = 3;\n    string stock_id = 4;\n    int32 quantity = 5;\n    int32 stock_before = 6;\n    int32 stock_after = 7;\n}\n\n// ==================== Confirm Reservation ====================\n\nmessage ConfirmReservationRequest {\n    string organization_id = 1;\n    string reservation_id = 2;\n    string order_id = 3;\n}\n\nmessage ConfirmReservationResponse {\n    bool success = 1;\n    string message = 2;\n    string confirmed_at = 3;  // ISO 8601 timestamp\n}\n\n// ==================== Release Reservation ====================\n\nmessage ReleaseReservationRequest {\n    string organization_id = 1;\n    string reservation_id = 2;\n    string reason = 3;  // payment_failed, timeout, cancelled\n}\n\nmessage ReleaseReservationResponse {\n    bool success = 1;\n    string message = 2;\n    int32 items_released = 3;\n    int32 total_quantity_released = 4;\n}\n\n// ==================== Get Stock Info ====================\n\nmessage GetStockInfoRequest {\n    string organization_id = 1;\n    string variant_id = 2;\n    string warehouse_id = 3;  // Opcional\n}\n\nmessage GetStockInfoResponse {\n    repeated StockInfo stock_info = 1;\n}\n\nmessage StockInfo {\n    string stock_id = 1;\n    string variant_id = 2;\n    string warehouse_id = 3;\n    string warehouse_name = 4;\n    int32 total_quantity = 5;\n    int32 available_quantity = 6;\n    int32 reserved_quantity = 7;\n    int32 damaged_quantity = 8;\n    int32 in_transit_quantity = 9;\n    int32 min_stock = 10;\n    int32 max_stock = 11;\n    string stock_status = 12;  // in_stock, low_stock, out_of_stock\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"implementaci\xf3n-del-servidor",children:"Implementaci\xf3n del Servidor"}),"\n",(0,r.jsx)(n.h3,{id:"server-setup",children:"Server Setup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import grpc\nfrom concurrent import futures\nimport logging\n\nfrom generated import inventory_pb2\nfrom generated import inventory_pb2_grpc\nfrom app.services.inventory_grpc_service import InventoryGRPCService\nfrom app.config.settings import settings\n\nlogger = logging.getLogger(__name__)\n\ndef serve():\n    \"\"\"Start gRPC server.\"\"\"\n    server = grpc.aio.server(\n        futures.ThreadPoolExecutor(max_workers=10),\n        options=[\n            ('grpc.max_send_message_length', 50 * 1024 * 1024),\n            ('grpc.max_receive_message_length', 50 * 1024 * 1024),\n        ]\n    )\n\n    inventory_pb2_grpc.add_InventoryServiceServicer_to_server(\n        InventoryGRPCService(), server\n    )\n\n    server.add_insecure_port(f'[::]:{settings.grpc_port}')\n\n    await server.start()\n    logger.info(f\"gRPC Server started on port {settings.grpc_port}\")\n\n    await server.wait_for_termination()\n\nif __name__ == '__main__':\n    serve()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"service-implementation",children:"Service Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import grpc\nfrom datetime import datetime, timedelta\nfrom typing import List\n\nfrom generated import inventory_pb2\nfrom generated import inventory_pb2_grpc\nfrom app.repositories.stock_repository import StockRepository\nfrom app.repositories.reservation_repository import ReservationRepository\nfrom app.services.stock_service import StockService\n\nclass InventoryGRPCService(inventory_pb2_grpc.InventoryServiceServicer):\n    """Implementation of Inventory gRPC Service."""\n\n    def __init__(self):\n        self.stock_repo = StockRepository()\n        self.reservation_repo = ReservationRepository()\n        self.stock_service = StockService()\n\n    async def CheckAvailability(\n        self,\n        request: inventory_pb2.CheckAvailabilityRequest,\n        context: grpc.aio.ServicerContext\n    ) -> inventory_pb2.CheckAvailabilityResponse:\n        """Check if stock is available for a variant."""\n        try:\n            # Buscar stock\n            stock = await self.stock_repo.find_by_variant_and_warehouse(\n                organization_id=request.organization_id,\n                variant_id=request.variant_id,\n                warehouse_id=request.warehouse_id if request.warehouse_id else None\n            )\n\n            if not stock:\n                return inventory_pb2.CheckAvailabilityResponse(\n                    available=False,\n                    available_quantity=0,\n                    message="Stock not found"\n                )\n\n            is_available = stock.available_quantity >= request.quantity\n\n            return inventory_pb2.CheckAvailabilityResponse(\n                available=is_available,\n                available_quantity=stock.available_quantity,\n                warehouse_id=stock.warehouse_id,\n                message="Available" if is_available else "Insufficient stock"\n            )\n\n        except Exception as e:\n            context.set_code(grpc.StatusCode.INTERNAL)\n            context.set_details(f"Error checking availability: {str(e)}")\n            raise\n\n    async def CheckBulkAvailability(\n        self,\n        request: inventory_pb2.CheckBulkAvailabilityRequest,\n        context: grpc.aio.ServicerContext\n    ) -> inventory_pb2.CheckBulkAvailabilityResponse:\n        """Check availability for multiple items."""\n        try:\n            results = []\n            all_available = True\n\n            for item in request.items:\n                stock = await self.stock_repo.find_by_variant_and_warehouse(\n                    organization_id=request.organization_id,\n                    variant_id=item.variant_id,\n                    warehouse_id=item.warehouse_id if item.warehouse_id else None\n                )\n\n                if not stock:\n                    results.append(inventory_pb2.AvailabilityResult(\n                        variant_id=item.variant_id,\n                        available=False,\n                        available_quantity=0,\n                        requested_quantity=item.quantity,\n                        message="Stock not found"\n                    ))\n                    all_available = False\n                    continue\n\n                is_available = stock.available_quantity >= item.quantity\n\n                results.append(inventory_pb2.AvailabilityResult(\n                    variant_id=item.variant_id,\n                    warehouse_id=stock.warehouse_id,\n                    available=is_available,\n                    available_quantity=stock.available_quantity,\n                    requested_quantity=item.quantity,\n                    message="Available" if is_available else "Insufficient stock"\n                ))\n\n                if not is_available:\n                    all_available = False\n\n            return inventory_pb2.CheckBulkAvailabilityResponse(\n                all_available=all_available,\n                results=results\n            )\n\n        except Exception as e:\n            context.set_code(grpc.StatusCode.INTERNAL)\n            context.set_details(f"Error checking bulk availability: {str(e)}")\n            raise\n\n    async def ReserveStock(\n        self,\n        request: inventory_pb2.ReserveStockRequest,\n        context: grpc.aio.ServicerContext\n    ) -> inventory_pb2.ReserveStockResponse:\n        """Reserve stock for an order."""\n        try:\n            # Validar TTL\n            ttl_minutes = request.ttl_minutes if request.ttl_minutes > 0 else 15\n            expires_at = datetime.utcnow() + timedelta(minutes=ttl_minutes)\n\n            # Crear reservaci\xf3n\n            reservation = await self.reservation_repo.create(\n                organization_id=request.organization_id,\n                order_id=request.order_id,\n                status=\'active\',\n                expires_at=expires_at\n            )\n\n            reserved_items = []\n\n            for item in request.items:\n                # Buscar stock\n                stock = await self.stock_repo.find_available_stock(\n                    organization_id=request.organization_id,\n                    variant_id=item.variant_id,\n                    warehouse_id=item.warehouse_id if item.warehouse_id else None,\n                    quantity_needed=item.quantity\n                )\n\n                if not stock:\n                    # Rollback reservaci\xf3n\n                    await self.reservation_repo.cancel(reservation.reservation_id)\n\n                    context.set_code(grpc.StatusCode.FAILED_PRECONDITION)\n                    context.set_details(f"Insufficient stock for variant {item.variant_id}")\n                    raise grpc.RpcError()\n\n                # Reservar stock\n                stock_before = stock.available_quantity\n                stock_after = stock_before - item.quantity\n\n                # Actualizar stock\n                await self.stock_repo.update_quantities(\n                    stock_id=stock.stock_id,\n                    available_quantity=stock_after,\n                    reserved_quantity=stock.reserved_quantity + item.quantity\n                )\n\n                # Crear reservation item\n                res_item = await self.reservation_repo.create_item(\n                    reservation_id=reservation.reservation_id,\n                    stock_id=stock.stock_id,\n                    variant_id=item.variant_id,\n                    warehouse_id=stock.warehouse_id,\n                    quantity=item.quantity,\n                    stock_before=stock_before,\n                    stock_after=stock_after\n                )\n\n                reserved_items.append(inventory_pb2.ReservedItem(\n                    reservation_item_id=str(res_item.reservation_item_id),\n                    variant_id=item.variant_id,\n                    warehouse_id=stock.warehouse_id,\n                    stock_id=str(stock.stock_id),\n                    quantity=item.quantity,\n                    stock_before=stock_before,\n                    stock_after=stock_after\n                ))\n\n            return inventory_pb2.ReserveStockResponse(\n                success=True,\n                reservation_id=str(reservation.reservation_id),\n                reserved_items=reserved_items,\n                expires_at=expires_at.isoformat(),\n                message="Stock reserved successfully"\n            )\n\n        except grpc.RpcError:\n            raise\n        except Exception as e:\n            context.set_code(grpc.StatusCode.INTERNAL)\n            context.set_details(f"Error reserving stock: {str(e)}")\n            raise\n\n    async def ConfirmReservation(\n        self,\n        request: inventory_pb2.ConfirmReservationRequest,\n        context: grpc.aio.ServicerContext\n    ) -> inventory_pb2.ConfirmReservationResponse:\n        """Confirm a reservation (payment succeeded)."""\n        try:\n            # Actualizar estado de reservaci\xf3n\n            reservation = await self.reservation_repo.confirm(\n                reservation_id=request.reservation_id,\n                organization_id=request.organization_id\n            )\n\n            if not reservation:\n                context.set_code(grpc.StatusCode.NOT_FOUND)\n                context.set_details("Reservation not found")\n                raise grpc.RpcError()\n\n            return inventory_pb2.ConfirmReservationResponse(\n                success=True,\n                message="Reservation confirmed",\n                confirmed_at=datetime.utcnow().isoformat()\n            )\n\n        except grpc.RpcError:\n            raise\n        except Exception as e:\n            context.set_code(grpc.StatusCode.INTERNAL)\n            context.set_details(f"Error confirming reservation: {str(e)}")\n            raise\n\n    async def ReleaseReservation(\n        self,\n        request: inventory_pb2.ReleaseReservationRequest,\n        context: grpc.aio.ServicerContext\n    ) -> inventory_pb2.ReleaseReservationResponse:\n        """Release a reservation (payment failed or timeout)."""\n        try:\n            # Liberar reservaci\xf3n\n            result = await self.reservation_repo.release(\n                reservation_id=request.reservation_id,\n                organization_id=request.organization_id,\n                reason=request.reason\n            )\n\n            return inventory_pb2.ReleaseReservationResponse(\n                success=True,\n                message="Reservation released",\n                items_released=result[\'items_count\'],\n                total_quantity_released=result[\'total_quantity\']\n            )\n\n        except Exception as e:\n            context.set_code(grpc.StatusCode.INTERNAL)\n            context.set_details(f"Error releasing reservation: {str(e)}")\n            raise\n\n    async def GetStockInfo(\n        self,\n        request: inventory_pb2.GetStockInfoRequest,\n        context: grpc.aio.ServicerContext\n    ) -> inventory_pb2.GetStockInfoResponse:\n        """Get stock information for a variant."""\n        try:\n            stocks = await self.stock_repo.find_all_by_variant(\n                organization_id=request.organization_id,\n                variant_id=request.variant_id,\n                warehouse_id=request.warehouse_id if request.warehouse_id else None\n            )\n\n            stock_info_list = []\n\n            for stock in stocks:\n                # Determinar stock status\n                if stock.available_quantity == 0:\n                    stock_status = "out_of_stock"\n                elif stock.available_quantity <= stock.min_stock:\n                    stock_status = "low_stock"\n                else:\n                    stock_status = "in_stock"\n\n                stock_info_list.append(inventory_pb2.StockInfo(\n                    stock_id=str(stock.stock_id),\n                    variant_id=stock.variant_id,\n                    warehouse_id=stock.warehouse_id,\n                    warehouse_name=stock.warehouse.name,\n                    total_quantity=stock.total_quantity,\n                    available_quantity=stock.available_quantity,\n                    reserved_quantity=stock.reserved_quantity,\n                    damaged_quantity=stock.damaged_quantity,\n                    in_transit_quantity=stock.in_transit_quantity,\n                    min_stock=stock.min_stock,\n                    max_stock=stock.max_stock,\n                    stock_status=stock_status\n                ))\n\n            return inventory_pb2.GetStockInfoResponse(\n                stock_info=stock_info_list\n            )\n\n        except Exception as e:\n            context.set_code(grpc.StatusCode.INTERNAL)\n            context.set_details(f"Error getting stock info: {str(e)}")\n            raise\n'})}),"\n",(0,r.jsx)(n.h2,{id:"ejemplos-de-uso-desde-order-service",children:"Ejemplos de Uso desde Order Service"}),"\n",(0,r.jsx)(n.h3,{id:"python-client",children:"Python Client"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import grpc\nfrom generated import inventory_pb2\nfrom generated import inventory_pb2_grpc\n\nclass InventoryClient:\n    \"\"\"Client for Inventory gRPC Service.\"\"\"\n\n    def __init__(self, host='localhost', port=50053):\n        self.channel = grpc.aio.insecure_channel(f'{host}:{port}')\n        self.stub = inventory_pb2_grpc.InventoryServiceStub(self.channel)\n\n    async def check_availability(\n        self,\n        organization_id: str,\n        variant_id: str,\n        warehouse_id: str,\n        quantity: int\n    ):\n        \"\"\"Check if stock is available.\"\"\"\n        request = inventory_pb2.CheckAvailabilityRequest(\n            organization_id=organization_id,\n            variant_id=variant_id,\n            warehouse_id=warehouse_id,\n            quantity=quantity\n        )\n\n        response = await self.stub.CheckAvailability(request)\n        return response\n\n    async def reserve_stock(\n        self,\n        organization_id: str,\n        order_id: str,\n        items: list,\n        ttl_minutes: int = 15\n    ):\n        \"\"\"Reserve stock for an order.\"\"\"\n        reservation_items = [\n            inventory_pb2.ReservationItem(\n                variant_id=item['variant_id'],\n                warehouse_id=item.get('warehouse_id', ''),\n                quantity=item['quantity']\n            )\n            for item in items\n        ]\n\n        request = inventory_pb2.ReserveStockRequest(\n            organization_id=organization_id,\n            order_id=order_id,\n            items=reservation_items,\n            ttl_minutes=ttl_minutes\n        )\n\n        response = await self.stub.ReserveStock(request)\n        return response\n\n    async def confirm_reservation(\n        self,\n        organization_id: str,\n        reservation_id: str,\n        order_id: str\n    ):\n        \"\"\"Confirm a reservation.\"\"\"\n        request = inventory_pb2.ConfirmReservationRequest(\n            organization_id=organization_id,\n            reservation_id=reservation_id,\n            order_id=order_id\n        )\n\n        response = await self.stub.ConfirmReservation(request)\n        return response\n\n    async def release_reservation(\n        self,\n        organization_id: str,\n        reservation_id: str,\n        reason: str\n    ):\n        \"\"\"Release a reservation.\"\"\"\n        request = inventory_pb2.ReleaseReservationRequest(\n            organization_id=organization_id,\n            reservation_id=reservation_id,\n            reason=reason\n        )\n\n        response = await self.stub.ReleaseReservation(request)\n        return response\n\n# Uso\nclient = InventoryClient(host='localhost', port=50053)\n\n# Check availability\nresponse = await client.check_availability(\n    organization_id='org_123',\n    variant_id='var_789',\n    warehouse_id='wh_101',\n    quantity=5\n)\nprint(f\"Available: {response.available}, Quantity: {response.available_quantity}\")\n\n# Reserve stock\nresponse = await client.reserve_stock(\n    organization_id='org_123',\n    order_id='order_456',\n    items=[\n        {'variant_id': 'var_789', 'warehouse_id': 'wh_101', 'quantity': 2},\n        {'variant_id': 'var_456', 'quantity': 1}  # Auto-select warehouse\n    ],\n    ttl_minutes=15\n)\nprint(f\"Reservation ID: {response.reservation_id}\")\nprint(f\"Expires at: {response.expires_at}\")\n"})}),"\n",(0,r.jsx)(n.h2,{id:"manejo-de-errores",children:"Manejo de Errores"}),"\n",(0,r.jsx)(n.h3,{id:"error-codes",children:"Error Codes"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"gRPC Code"}),(0,r.jsx)(n.th,{children:"Descripci\xf3n"}),(0,r.jsx)(n.th,{children:"Cu\xe1ndo ocurre"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"OK"})}),(0,r.jsx)(n.td,{children:"Success"}),(0,r.jsx)(n.td,{children:"Operaci\xf3n exitosa"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"NOT_FOUND"})}),(0,r.jsx)(n.td,{children:"No encontrado"}),(0,r.jsx)(n.td,{children:"Stock o reservaci\xf3n no existe"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"FAILED_PRECONDITION"})}),(0,r.jsx)(n.td,{children:"Precondici\xf3n fallida"}),(0,r.jsx)(n.td,{children:"Stock insuficiente"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"INVALID_ARGUMENT"})}),(0,r.jsx)(n.td,{children:"Argumento inv\xe1lido"}),(0,r.jsx)(n.td,{children:"Datos de entrada incorrectos"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"DEADLINE_EXCEEDED"})}),(0,r.jsx)(n.td,{children:"Timeout"}),(0,r.jsx)(n.td,{children:"Operaci\xf3n tard\xf3 demasiado"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"INTERNAL"})}),(0,r.jsx)(n.td,{children:"Error interno"}),(0,r.jsx)(n.td,{children:"Error inesperado del servidor"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"UNAVAILABLE"})}),(0,r.jsx)(n.td,{children:"Servicio no disponible"}),(0,r.jsx)(n.td,{children:"Servidor ca\xeddo o mantenimiento"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"retry-strategy",children:"Retry Strategy"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from grpc import StatusCode\nimport asyncio\n\nasync def call_with_retry(func, max_retries=3, backoff=1):\n    \"\"\"Call gRPC function with retry logic.\"\"\"\n    for attempt in range(max_retries):\n        try:\n            return await func()\n        except grpc.RpcError as e:\n            if e.code() in [StatusCode.UNAVAILABLE, StatusCode.DEADLINE_EXCEEDED]:\n                if attempt < max_retries - 1:\n                    await asyncio.sleep(backoff * (2 ** attempt))\n                    continue\n            raise\n\n# Uso\nresponse = await call_with_retry(\n    lambda: client.check_availability('org_123', 'var_789', 'wh_101', 5)\n)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"circuit-breaker",children:"Circuit Breaker"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from datetime import datetime, timedelta\n\nclass CircuitBreaker:\n    \"\"\"Circuit breaker pattern for gRPC calls.\"\"\"\n\n    def __init__(self, failure_threshold=5, timeout=60):\n        self.failure_threshold = failure_threshold\n        self.timeout = timeout\n        self.failures = 0\n        self.last_failure_time = None\n        self.state = 'closed'  # closed, open, half_open\n\n    async def call(self, func):\n        if self.state == 'open':\n            if datetime.now() - self.last_failure_time > timedelta(seconds=self.timeout):\n                self.state = 'half_open'\n            else:\n                raise Exception(\"Circuit breaker is OPEN\")\n\n        try:\n            result = await func()\n            self.on_success()\n            return result\n        except Exception as e:\n            self.on_failure()\n            raise\n\n    def on_success(self):\n        self.failures = 0\n        self.state = 'closed'\n\n    def on_failure(self):\n        self.failures += 1\n        self.last_failure_time = datetime.now()\n        if self.failures >= self.failure_threshold:\n            self.state = 'open'\n"})}),"\n",(0,r.jsx)(n.h2,{id:"health-check",children:"Health Check"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from grpc_health.v1 import health_pb2\nfrom grpc_health.v1 import health_pb2_grpc\n\n# Server side\nasync def check_health():\n    """Check if service is healthy."""\n    # Verificar conexi\xf3n a DB\n    # Verificar Redis\n    # etc.\n    return health_pb2.HealthCheckResponse.SERVING\n\n# Client side\nhealth_stub = health_pb2_grpc.HealthStub(channel)\nresponse = await health_stub.Check(\n    health_pb2.HealthCheckRequest(service=\'InventoryService\')\n)\nprint(response.status)  # SERVING, NOT_SERVING, UNKNOWN\n'})}),"\n",(0,r.jsx)(n.h2,{id:"pr\xf3ximos-pasos",children:"Pr\xf3ximos Pasos"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"./configuracion",children:"Configuraci\xf3n"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"./modelo-datos",children:"Modelo de Datos"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"./integraciones",children:"Integraciones"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"./eventos-publicados",children:"Eventos Publicados"})}),"\n"]})]})}function _(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(6540);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);