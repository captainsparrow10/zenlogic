"use strict";(globalThis.webpackChunkerp_docs=globalThis.webpackChunkerp_docs||[]).push([[2242],{8412:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>t,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"integraciones/redis","title":"Redis - Cache y Sesiones","description":"Integraci\xf3n con Redis para cache distribuido y gesti\xf3n de sesiones.","source":"@site/docs/04-integraciones/02-redis.md","sourceDirName":"04-integraciones","slug":"/integraciones/redis","permalink":"/zenlogic/integraciones/redis","draft":false,"unlisted":false,"editUrl":"https://github.com/your-repo/edit/main/docs/04-integraciones/02-redis.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"docs","previous":{"title":"RabbitMQ - Message Broker","permalink":"/zenlogic/integraciones/rabbitmq"},"next":{"title":"gRPC - Comunicaci\xf3n Interna","permalink":"/zenlogic/integraciones/grpc"}}');var a=i(4848),r=i(8453);const c={sidebar_position:3},t="Redis - Cache y Sesiones",o={},d=[{value:"Overview",id:"overview",level:2},{value:"Configuraci\xf3n",id:"configuraci\xf3n",level:2},{value:"Instalaci\xf3n",id:"instalaci\xf3n",level:3},{value:"Variables de Entorno",id:"variables-de-entorno",level:3},{value:"Cliente Async",id:"cliente-async",level:3},{value:"Cache Service",id:"cache-service",level:2},{value:"Implementaci\xf3n",id:"implementaci\xf3n",level:3},{value:"Patrones de Cache",id:"patrones-de-cache",level:2},{value:"1. Cache-Aside (Lazy Loading)",id:"1-cache-aside-lazy-loading",level:3},{value:"2. Write-Through Cache",id:"2-write-through-cache",level:3},{value:"3. Cache Invalidation",id:"3-cache-invalidation",level:3},{value:"Casos de Uso Espec\xedficos",id:"casos-de-uso-espec\xedficos",level:2},{value:"1. Cache de Permisos de Usuario",id:"1-cache-de-permisos-de-usuario",level:3},{value:"2. Cache de Locales de Organizaci\xf3n",id:"2-cache-de-locales-de-organizaci\xf3n",level:3},{value:"3. Session Store",id:"3-session-store",level:3},{value:"Redis Pub/Sub para Invalidaci\xf3n",id:"redis-pubsub-para-invalidaci\xf3n",level:2},{value:"Publisher",id:"publisher",level:3},{value:"Subscriber",id:"subscriber",level:3},{value:"Estrategias de TTL",id:"estrategias-de-ttl",level:2},{value:"TTLs Recomendados",id:"ttls-recomendados",level:3},{value:"Monitoreo",id:"monitoreo",level:2},{value:"M\xe9tricas",id:"m\xe9tricas",level:3},{value:"Health Check",id:"health-check",level:3},{value:"Monitoreo de Memoria",id:"monitoreo-de-memoria",level:3},{value:"Mejores Pr\xe1cticas",id:"mejores-pr\xe1cticas",level:2},{value:"1. Namespacing de Keys",id:"1-namespacing-de-keys",level:3},{value:"2. Serializaci\xf3n Consistente",id:"2-serializaci\xf3n-consistente",level:3},{value:"3. Fail Gracefully",id:"3-fail-gracefully",level:3},{value:"4. Evitar Cache Stampede",id:"4-evitar-cache-stampede",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Problema: Cache Hit Rate Bajo",id:"problema-cache-hit-rate-bajo",level:3},{value:"Problema: Redis Out of Memory",id:"problema-redis-out-of-memory",level:3},{value:"Pr\xf3ximos Pasos",id:"pr\xf3ximos-pasos",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"redis---cache-y-sesiones",children:"Redis - Cache y Sesiones"})}),"\n",(0,a.jsx)(n.p,{children:"Integraci\xf3n con Redis para cache distribuido y gesti\xf3n de sesiones."}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"Redis act\xfaa como capa de cache para reducir latencia y carga en PostgreSQL, adem\xe1s de almacenar sesiones de usuarios y facilitar la invalidaci\xf3n de cache coordinada entre servicios."}),"\n",(0,a.jsx)(n.mermaid,{value:"graph TB\n    Client[Client Request] --\x3e API[API Gateway]\n    API --\x3e Service[Microservice]\n\n    Service --\x3e Cache{Redis Cache}\n    Cache --\x3e|Hit| Return[Return Cached]\n    Cache --\x3e|Miss| DB[(PostgreSQL)]\n    DB --\x3e Update[Update Cache]\n    Update --\x3e Return\n\n    Service2[Other Service] --\x3e|Invalidate| Cache"}),"\n",(0,a.jsx)(n.h2,{id:"configuraci\xf3n",children:"Configuraci\xf3n"}),"\n",(0,a.jsx)(n.h3,{id:"instalaci\xf3n",children:"Instalaci\xf3n"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# Docker Compose\nversion: '3.8'\nservices:\n  redis:\n    image: redis:7-alpine\n    ports:\n      - \"6379:6379\"\n    command: redis-server --appendonly yes --maxmemory 256mb --maxmemory-policy allkeys-lru\n    volumes:\n      - redis_data:/data\n\nvolumes:\n  redis_data:\n"})}),"\n",(0,a.jsx)(n.h3,{id:"variables-de-entorno",children:"Variables de Entorno"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# .env\nREDIS_URL=redis://localhost:6379/0\nREDIS_MAX_CONNECTIONS=50\nREDIS_SOCKET_TIMEOUT=5\nREDIS_DECODE_RESPONSES=true\n"})}),"\n",(0,a.jsx)(n.h3,{id:"cliente-async",children:"Cliente Async"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# app/cache/redis_client.py\nimport aioredis\nfrom app.config import settings\n\nclass RedisClient:\n    """Cliente Redis singleton."""\n\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._client = None\n        return cls._instance\n\n    async def connect(self):\n        """Conectar a Redis."""\n        if self._client is None:\n            self._client = await aioredis.from_url(\n                settings.redis_url,\n                max_connections=settings.redis_max_connections,\n                decode_responses=True,\n                socket_timeout=settings.redis_socket_timeout\n            )\n            logger.info(f"Connected to Redis: {settings.redis_url}")\n\n    async def close(self):\n        """Cerrar conexi\xf3n."""\n        if self._client:\n            await self._client.close()\n\n    def get_client(self):\n        """Obtener cliente Redis."""\n        if self._client is None:\n            raise Exception("Redis not connected. Call connect() first.")\n        return self._client\n\n# Singleton instance\nredis_client = RedisClient()\n'})}),"\n",(0,a.jsx)(n.h2,{id:"cache-service",children:"Cache Service"}),"\n",(0,a.jsx)(n.h3,{id:"implementaci\xf3n",children:"Implementaci\xf3n"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# app/cache/cache_service.py\nimport json\nfrom typing import Any, Optional\nfrom datetime import timedelta\nfrom app.cache.redis_client import redis_client\n\nclass CacheService:\n    """Servicio de cache con Redis."""\n\n    def __init__(self):\n        self.redis = redis_client.get_client()\n\n    async def get(self, key: str) -> Optional[Any]:\n        """Obtener valor del cache."""\n\n        try:\n            value = await self.redis.get(key)\n\n            if value:\n                cache_hits.inc()\n                return json.loads(value)\n\n            cache_misses.inc()\n            return None\n\n        except Exception as e:\n            logger.error(f"Cache get error: {e}")\n            return None  # Fail gracefully\n\n    async def set(\n        self,\n        key: str,\n        value: Any,\n        ttl: int = 300  # 5 minutos por defecto\n    ):\n        """Guardar valor en cache con TTL."""\n\n        try:\n            serialized = json.dumps(value, default=str)\n            await self.redis.setex(key, ttl, serialized)\n\n        except Exception as e:\n            logger.error(f"Cache set error: {e}")\n\n    async def delete(self, key: str):\n        """Eliminar clave del cache."""\n\n        try:\n            await self.redis.delete(key)\n        except Exception as e:\n            logger.error(f"Cache delete error: {e}")\n\n    async def delete_pattern(self, pattern: str):\n        """Eliminar m\xfaltiples claves por patr\xf3n."""\n\n        try:\n            cursor = 0\n            while True:\n                cursor, keys = await self.redis.scan(\n                    cursor=cursor,\n                    match=pattern,\n                    count=100\n                )\n\n                if keys:\n                    await self.redis.delete(*keys)\n\n                if cursor == 0:\n                    break\n\n            logger.info(f"Deleted keys matching: {pattern}")\n\n        except Exception as e:\n            logger.error(f"Cache delete pattern error: {e}")\n\n    async def exists(self, key: str) -> bool:\n        """Verificar si clave existe."""\n        try:\n            return await self.redis.exists(key) > 0\n        except Exception as e:\n            logger.error(f"Cache exists error: {e}")\n            return False\n'})}),"\n",(0,a.jsx)(n.h2,{id:"patrones-de-cache",children:"Patrones de Cache"}),"\n",(0,a.jsx)(n.h3,{id:"1-cache-aside-lazy-loading",children:"1. Cache-Aside (Lazy Loading)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'async def get_product(product_id: str) -> Product:\n    """Obtener producto con cache."""\n\n    # 1. Intentar obtener de cache\n    cache_key = f"product:{product_id}"\n    cached = await cache_service.get(cache_key)\n\n    if cached:\n        logger.debug(f"Cache hit: {cache_key}")\n        return Product(**cached)\n\n    # 2. Cache miss \u2192 obtener de DB\n    logger.debug(f"Cache miss: {cache_key}")\n    product = await db.query(Product).filter_by(id=product_id).first()\n\n    if not product:\n        raise HTTPException(404, "Product not found")\n\n    # 3. Guardar en cache\n    await cache_service.set(\n        cache_key,\n        product.dict(),\n        ttl=300  # 5 minutos\n    )\n\n    return product\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-write-through-cache",children:"2. Write-Through Cache"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'async def update_product(product_id: str, updates: dict) -> Product:\n    """Actualizar producto y cache simult\xe1neamente."""\n\n    # 1. Actualizar en DB\n    product = await db.query(Product).filter_by(id=product_id).first()\n    for key, value in updates.items():\n        setattr(product, key, value)\n\n    await db.commit()\n    await db.refresh(product)\n\n    # 2. Actualizar cache inmediatamente\n    cache_key = f"product:{product_id}"\n    await cache_service.set(\n        cache_key,\n        product.dict(),\n        ttl=300\n    )\n\n    return product\n'})}),"\n",(0,a.jsx)(n.h3,{id:"3-cache-invalidation",children:"3. Cache Invalidation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'async def delete_product(product_id: str):\n    """Eliminar producto e invalidar cache."""\n\n    # 1. Eliminar de DB\n    await db.execute(\n        delete(Product).where(Product.id == product_id)\n    )\n    await db.commit()\n\n    # 2. Invalidar cache\n    await cache_service.delete(f"product:{product_id}")\n\n    # 3. Invalidar cache de listas relacionadas\n    await cache_service.delete_pattern(f"products:org:*")\n\n    # 4. Publicar evento de invalidaci\xf3n\n    await redis_pubsub.publish(\n        "cache_invalidation",\n        json.dumps({"pattern": f"product:{product_id}"})\n    )\n'})}),"\n",(0,a.jsx)(n.h2,{id:"casos-de-uso-espec\xedficos",children:"Casos de Uso Espec\xedficos"}),"\n",(0,a.jsx)(n.h3,{id:"1-cache-de-permisos-de-usuario",children:"1. Cache de Permisos de Usuario"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'async def get_user_permissions(user_id: str) -> set[str]:\n    """Obtener permisos de usuario con cache."""\n\n    cache_key = f"permissions:{user_id}"\n\n    # Intentar cache\n    cached = await cache_service.get(cache_key)\n    if cached:\n        return set(cached)\n\n    # Cache miss \u2192 query DB\n    permissions = await auth_service.get_permissions(user_id)\n\n    # Guardar en cache (TTL corto para permisos)\n    await cache_service.set(\n        cache_key,\n        list(permissions),\n        ttl=300  # 5 minutos\n    )\n\n    return permissions\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-cache-de-locales-de-organizaci\xf3n",children:"2. Cache de Locales de Organizaci\xf3n"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'async def get_organization_locals(org_id: str) -> list[dict]:\n    """Obtener locales de organizaci\xf3n con cache."""\n\n    cache_key = f"org:{org_id}:locals"\n\n    # Intentar cache\n    cached = await cache_service.get(cache_key)\n    if cached:\n        return cached\n\n    # Cache miss \u2192 query DB\n    locals = await db.query(Local).filter_by(\n        organization_id=org_id,\n        is_active=True\n    ).all()\n\n    locals_data = [local.dict() for local in locals]\n\n    # Guardar en cache (TTL m\xe1s largo)\n    await cache_service.set(\n        cache_key,\n        locals_data,\n        ttl=3600  # 1 hora\n    )\n\n    return locals_data\n'})}),"\n",(0,a.jsx)(n.h3,{id:"3-session-store",children:"3. Session Store"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# Guardar sesi\xf3n de usuario\nasync def create_session(user_id: str, data: dict) -> str:\n    """Crear sesi\xf3n de usuario."""\n\n    session_id = str(uuid4())\n    session_key = f"session:{session_id}"\n\n    session_data = {\n        "user_id": user_id,\n        "created_at": datetime.utcnow().isoformat(),\n        **data\n    }\n\n    # Guardar en Redis con TTL de sesi\xf3n\n    await cache_service.set(\n        session_key,\n        session_data,\n        ttl=86400  # 24 horas\n    )\n\n    return session_id\n\n# Obtener sesi\xf3n\nasync def get_session(session_id: str) -> Optional[dict]:\n    """Obtener sesi\xf3n de usuario."""\n\n    session_key = f"session:{session_id}"\n    return await cache_service.get(session_key)\n\n# Extender sesi\xf3n (refresh TTL)\nasync def extend_session(session_id: str):\n    """Extender TTL de sesi\xf3n."""\n\n    session_key = f"session:{session_id}"\n    await redis_client.get_client().expire(session_key, 86400)\n\n# Eliminar sesi\xf3n (logout)\nasync def delete_session(session_id: str):\n    """Eliminar sesi\xf3n de usuario."""\n\n    session_key = f"session:{session_id}"\n    await cache_service.delete(session_key)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"redis-pubsub-para-invalidaci\xf3n",children:"Redis Pub/Sub para Invalidaci\xf3n"}),"\n",(0,a.jsx)(n.h3,{id:"publisher",children:"Publisher"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# Servicio que actualiza datos\nasync def update_product_price(product_id: str, new_price: float):\n    """Actualizar precio y notificar a otros servicios."""\n\n    # Actualizar DB\n    await db.execute(\n        update(Product)\n        .where(Product.id == product_id)\n        .values(base_price=new_price)\n    )\n    await db.commit()\n\n    # Publicar invalidaci\xf3n\n    redis_pubsub = redis_client.get_client()\n    await redis_pubsub.publish(\n        "cache_invalidation",\n        json.dumps({\n            "pattern": f"product:{product_id}",\n            "reason": "price_updated"\n        })\n    )\n'})}),"\n",(0,a.jsx)(n.h3,{id:"subscriber",children:"Subscriber"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# Servicio que escucha invalidaciones\nasync def cache_invalidation_subscriber():\n    """Escuchar invalidaciones de cache."""\n\n    redis_pubsub = redis_client.get_client().pubsub()\n    await redis_pubsub.subscribe("cache_invalidation")\n\n    async for message in redis_pubsub.listen():\n        if message["type"] == "message":\n            data = json.loads(message["data"])\n            pattern = data.get("pattern")\n\n            logger.info(f"Cache invalidation: {pattern}")\n\n            # Invalidar cache local\n            await cache_service.delete_pattern(pattern)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"estrategias-de-ttl",children:"Estrategias de TTL"}),"\n",(0,a.jsx)(n.h3,{id:"ttls-recomendados",children:"TTLs Recomendados"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# Configuraci\xf3n de TTLs por tipo de dato\nCACHE_TTL = {\n    # Datos est\xe1ticos\n    "permissions": 300,        # 5 minutos\n    "roles": 600,              # 10 minutos\n    "organizations": 3600,     # 1 hora\n\n    # Datos semi-est\xe1ticos\n    "locals": 3600,            # 1 hora\n    "products": 300,           # 5 minutos\n    "variants": 300,           # 5 minutos\n\n    # Datos din\xe1micos\n    "stock": 60,               # 1 minuto\n    "prices": 300,             # 5 minutos\n\n    # Sesiones\n    "sessions": 86400,         # 24 horas\n    "refresh_tokens": 604800,  # 7 d\xedas\n}\n\ndef get_ttl(cache_type: str) -> int:\n    """Obtener TTL para tipo de cache."""\n    return CACHE_TTL.get(cache_type, 300)  # Default 5 min\n'})}),"\n",(0,a.jsx)(n.h2,{id:"monitoreo",children:"Monitoreo"}),"\n",(0,a.jsx)(n.h3,{id:"m\xe9tricas",children:"M\xe9tricas"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from prometheus_client import Counter, Gauge, Histogram\n\ncache_hits = Counter(\n    "cache_hits_total",\n    "Total cache hits"\n)\n\ncache_misses = Counter(\n    "cache_misses_total",\n    "Total cache misses"\n)\n\ncache_operations = Histogram(\n    "cache_operation_duration_seconds",\n    "Cache operation duration",\n    ["operation"]  # get, set, delete\n)\n\nredis_memory_usage = Gauge(\n    "redis_memory_usage_bytes",\n    "Redis memory usage in bytes"\n)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"health-check",children:"Health Check"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'@router.get("/health/redis")\nasync def redis_health():\n    """Health check de Redis."""\n\n    try:\n        redis = redis_client.get_client()\n\n        # Ping\n        await redis.ping()\n\n        # Info\n        info = await redis.info("memory")\n        memory_used = info.get("used_memory", 0)\n\n        return {\n            "status": "healthy",\n            "memory_used_mb": memory_used / (1024 * 1024)\n        }\n\n    except Exception as e:\n        return JSONResponse(\n            {"status": "unhealthy", "error": str(e)},\n            status_code=503\n        )\n'})}),"\n",(0,a.jsx)(n.h3,{id:"monitoreo-de-memoria",children:"Monitoreo de Memoria"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'async def monitor_redis_memory():\n    """Monitorear uso de memoria de Redis."""\n\n    redis = redis_client.get_client()\n    info = await redis.info("memory")\n\n    memory_used = info["used_memory"]\n    memory_max = info["maxmemory"]\n\n    if memory_max > 0:\n        usage_percentage = (memory_used / memory_max) * 100\n\n        if usage_percentage > 80:\n            logger.warning(\n                f"Redis memory usage high: {usage_percentage:.2f}%"\n            )\n\n        redis_memory_usage.set(memory_used)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"mejores-pr\xe1cticas",children:"Mejores Pr\xe1cticas"}),"\n",(0,a.jsx)(n.h3,{id:"1-namespacing-de-keys",children:"1. Namespacing de Keys"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# \u2705 BIEN: Keys con namespace\nproduct_key = f"product:{product_id}"\nuser_perms_key = f"permissions:{user_id}"\norg_locals_key = f"org:{org_id}:locals"\n\n# \u274c MAL: Keys sin namespace\nproduct_key = product_id\nuser_perms_key = user_id\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-serializaci\xf3n-consistente",children:"2. Serializaci\xf3n Consistente"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Siempre usar JSON para serializaci\xf3n\n# NO usar pickle (no es portable)\n\n# \u2705 BIEN\nawait cache_service.set(key, json.dumps(data))\n\n# \u274c MAL\nawait cache_service.set(key, pickle.dumps(data))\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-fail-gracefully",children:"3. Fail Gracefully"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'async def get_product_with_fallback(product_id: str):\n    """Obtener producto con fallback si cache falla."""\n\n    try:\n        # Intentar cache\n        cached = await cache_service.get(f"product:{product_id}")\n        if cached:\n            return cached\n    except Exception as e:\n        logger.warning(f"Cache error, falling back to DB: {e}")\n\n    # Fallback a DB\n    return await db.query(Product).filter_by(id=product_id).first()\n'})}),"\n",(0,a.jsx)(n.h3,{id:"4-evitar-cache-stampede",children:"4. Evitar Cache Stampede"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import asyncio\nfrom asyncio import Lock\n\n# Lock por clave para evitar stampede\nlocks: dict[str, Lock] = {}\n\nasync def get_with_lock(key: str, fetch_func):\n    """Obtener con lock para evitar cache stampede."""\n\n    # Intentar cache\n    cached = await cache_service.get(key)\n    if cached:\n        return cached\n\n    # Cache miss \u2192 adquirir lock\n    if key not in locks:\n        locks[key] = Lock()\n\n    async with locks[key]:\n        # Double-check cache\n        cached = await cache_service.get(key)\n        if cached:\n            return cached\n\n        # Fetch y cache\n        data = await fetch_func()\n        await cache_service.set(key, data)\n        return data\n'})}),"\n",(0,a.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,a.jsx)(n.h3,{id:"problema-cache-hit-rate-bajo",children:"Problema: Cache Hit Rate Bajo"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Causas"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"TTL muy corto"}),"\n",(0,a.jsx)(n.li,{children:"Claves incorrectas"}),"\n",(0,a.jsx)(n.li,{children:"Datos muy din\xe1micos"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Soluci\xf3n"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# Calcular hit rate\nhit_rate = cache_hits.get() / (cache_hits.get() + cache_misses.get())\nlogger.info(f"Cache hit rate: {hit_rate:.2%}")\n\n# Si menor a 60%, investigar:\n# 1. Aumentar TTLs\n# 2. Revisar claves de cache\n# 3. Identificar datos que no deber\xedan cachearse\n'})}),"\n",(0,a.jsx)(n.h3,{id:"problema-redis-out-of-memory",children:"Problema: Redis Out of Memory"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Causas"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Demasiados datos"}),"\n",(0,a.jsx)(n.li,{children:"TTLs muy largos"}),"\n",(0,a.jsx)(n.li,{children:"Memory leaks"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Soluci\xf3n"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# Ver uso de memoria\nredis-cli INFO memory\n\n# Ver claves m\xe1s grandes\nredis-cli --bigkeys\n\n# Configurar eviction policy\nredis-cli CONFIG SET maxmemory-policy allkeys-lru\n"})}),"\n",(0,a.jsx)(n.h2,{id:"pr\xf3ximos-pasos",children:"Pr\xf3ximos Pasos"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"/integraciones/grpc",children:"gRPC - Comunicaci\xf3n Interna"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"/microservicios/catalog-service/cache-strategy",children:"Catalog Service - Cache Strategy"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"/integraciones/postgresql",children:"PostgreSQL"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>c,x:()=>t});var s=i(6540);const a={},r=s.createContext(a);function c(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);