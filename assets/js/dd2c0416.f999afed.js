"use strict";(globalThis.webpackChunkerp_docs=globalThis.webpackChunkerp_docs||[]).push([[4107],{3752:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>r,contentTitle:()=>o,default:()=>_,frontMatter:()=>s,metadata:()=>i,toc:()=>t});const i=JSON.parse('{"id":"microservicios/catalog-service/validacion-locales","title":"Validaci\xf3n de Locales","description":"Middleware y l\xf3gica para validar que usuarios tengan acceso a locales en operaciones del cat\xe1logo.","source":"@site/docs/02-microservicios/catalog-service/07-validacion-locales.md","sourceDirName":"02-microservicios/catalog-service","slug":"/microservicios/catalog-service/validacion-locales","permalink":"/zenlogic/microservicios/catalog-service/validacion-locales","draft":false,"unlisted":false,"editUrl":"https://github.com/your-repo/edit/main/docs/02-microservicios/catalog-service/07-validacion-locales.md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"docs","previous":{"title":"Eventos Consumidos","permalink":"/zenlogic/microservicios/catalog-service/eventos-consumidos"},"next":{"title":"Auth Client gRPC","permalink":"/zenlogic/microservicios/catalog-service/auth-client-grpc"}}');var l=n(4848),c=n(8453);const s={sidebar_position:8},o="Validaci\xf3n de Locales",r={},t=[{value:"Arquitectura de Validaci\xf3n",id:"arquitectura-de-validaci\xf3n",level:2},{value:"Middleware de Validaci\xf3n",id:"middleware-de-validaci\xf3n",level:2},{value:"<code>middlewares/local_validation.py</code>",id:"middlewareslocal_validationpy",level:3},{value:"Dependency Injection",id:"dependency-injection",level:2},{value:"<code>dependencies.py</code>",id:"dependenciespy",level:3},{value:"Uso en Endpoints",id:"uso-en-endpoints",level:2},{value:"Opci\xf3n 1: Dependency en Endpoint",id:"opci\xf3n-1-dependency-en-endpoint",level:3},{value:"Opci\xf3n 2: Validaci\xf3n Manual en Service Layer",id:"opci\xf3n-2-validaci\xf3n-manual-en-service-layer",level:3},{value:"Cache de Locales",id:"cache-de-locales",level:2},{value:"Estrategia de Invalidaci\xf3n",id:"estrategia-de-invalidaci\xf3n",level:3},{value:"Sincronizaci\xf3n con Eventos",id:"sincronizaci\xf3n-con-eventos",level:3},{value:"Testing",id:"testing",level:2},{value:"Unit Test",id:"unit-test",level:3},{value:"Logs y Monitoreo",id:"logs-y-monitoreo",level:2},{value:"M\xe9tricas",id:"m\xe9tricas",level:2},{value:"Pr\xf3ximos Pasos",id:"pr\xf3ximos-pasos",level:2}];function d(e){const a={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",ul:"ul",...(0,c.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(a.header,{children:(0,l.jsx)(a.h1,{id:"validaci\xf3n-de-locales",children:"Validaci\xf3n de Locales"})}),"\n",(0,l.jsx)(a.p,{children:"Middleware y l\xf3gica para validar que usuarios tengan acceso a locales en operaciones del cat\xe1logo."}),"\n",(0,l.jsx)(a.h2,{id:"arquitectura-de-validaci\xf3n",children:"Arquitectura de Validaci\xf3n"}),"\n",(0,l.jsx)(a.mermaid,{value:"sequenceDiagram\n    participant Client\n    participant Middleware\n    participant Cache\n    participant AuthGRPC\n    participant CatalogService\n\n    Client->>Middleware: GET /products?local_id=123\n    Middleware->>Middleware: Extraer local_id del query/body\n    Middleware->>Cache: GET locals:org_id:user_id\n\n    alt Cache hit\n        Cache--\x3e>Middleware: Lista de locales\n    else Cache miss\n        Middleware->>AuthGRPC: GetUserLocals(user_id, org_id)\n        AuthGRPC--\x3e>Middleware: Lista de locales\n        Middleware->>Cache: SETEX locals:org_id:user_id\n    end\n\n    Middleware->>Middleware: Validar local_id en lista\n\n    alt Local v\xe1lido\n        Middleware->>CatalogService: Continuar request\n        CatalogService--\x3e>Client: 200 OK + productos\n    else Local inv\xe1lido\n        Middleware--\x3e>Client: 403 Forbidden\n    end"}),"\n",(0,l.jsx)(a.h2,{id:"middleware-de-validaci\xf3n",children:"Middleware de Validaci\xf3n"}),"\n",(0,l.jsx)(a.h3,{id:"middlewareslocal_validationpy",children:(0,l.jsx)(a.code,{children:"middlewares/local_validation.py"})}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-python",children:'from fastapi import Request, HTTPException, status\nfrom fastapi.responses import JSONResponse\nfrom typing import Optional, List\nimport logging\n\nfrom app.clients.auth_client import AuthClient\nfrom app.cache.redis_client import RedisCache\n\nlogger = logging.getLogger(__name__)\n\n\nclass LocalValidationMiddleware:\n    """\n    Middleware para validar acceso a locales.\n\n    Verifica que el usuario tenga permisos sobre el local solicitado.\n    """\n\n    def __init__(\n        self,\n        auth_client: AuthClient,\n        cache: RedisCache\n    ):\n        self.auth_client = auth_client\n        self.cache = cache\n\n    async def __call__(self, request: Request, call_next):\n        """Ejecutar validaci\xf3n de local."""\n\n        # Extraer datos del request\n        user_id = request.state.user_id  # Seteado por auth middleware\n        org_id = request.state.organization_id\n\n        # Extraer local_id del request\n        local_id = await self._extract_local_id(request)\n\n        if local_id:\n            # Validar acceso al local\n            has_access = await self.validate_local_access(\n                user_id=user_id,\n                org_id=org_id,\n                local_id=local_id\n            )\n\n            if not has_access:\n                logger.warning(\n                    f"Usuario {user_id} intent\xf3 acceder a local {local_id} sin permisos",\n                    extra={"organization_id": org_id}\n                )\n                return JSONResponse(\n                    status_code=status.HTTP_403_FORBIDDEN,\n                    content={\n                        "detail": "No tienes acceso a este local",\n                        "error_code": "LOCAL_ACCESS_DENIED"\n                    }\n                )\n\n            # Guardar en request state para uso posterior\n            request.state.local_id = local_id\n\n        response = await call_next(request)\n        return response\n\n    async def _extract_local_id(self, request: Request) -> Optional[str]:\n        """\n        Extraer local_id del request.\n\n        Busca en:\n        1. Query parameters (?local_id=xxx)\n        2. Path parameters (/locals/{local_id}/products)\n        3. Request body (JSON)\n        """\n        # 1. Query parameters\n        local_id = request.query_params.get("local_id")\n        if local_id:\n            return local_id\n\n        # 2. Path parameters\n        if "local_id" in request.path_params:\n            return request.path_params["local_id"]\n\n        # 3. Request body (solo para POST/PUT/PATCH)\n        if request.method in ["POST", "PUT", "PATCH"]:\n            try:\n                body = await request.json()\n                if "local_id" in body:\n                    return body["local_id"]\n            except Exception:\n                pass\n\n        return None\n\n    async def validate_local_access(\n        self,\n        user_id: str,\n        org_id: str,\n        local_id: str\n    ) -> bool:\n        """\n        Validar que usuario tenga acceso al local.\n\n        Args:\n            user_id: ID del usuario\n            org_id: ID de la organizaci\xf3n\n            local_id: ID del local a validar\n\n        Returns:\n            True si tiene acceso, False en caso contrario\n        """\n        # Obtener locales del usuario (con cache)\n        user_locals = await self.get_user_locals(user_id, org_id)\n\n        # Verificar si local_id est\xe1 en la lista\n        return local_id in user_locals\n\n    async def get_user_locals(\n        self,\n        user_id: str,\n        org_id: str\n    ) -> List[str]:\n        """\n        Obtener lista de locales del usuario.\n\n        Usa cache de Redis con TTL de 1 hora.\n        """\n        cache_key = f"locals:{org_id}:{user_id}"\n\n        # Intentar obtener del cache\n        cached = await self.cache.get(cache_key)\n        if cached:\n            logger.debug(f"Cache hit para locales de usuario {user_id}")\n            return cached\n\n        # Cache miss - consultar Auth Service v\xeda gRPC\n        logger.debug(f"Cache miss - consultando Auth Service para usuario {user_id}")\n\n        try:\n            user_locals = await self.auth_client.get_user_locals(\n                user_id=user_id,\n                org_id=org_id\n            )\n\n            # Guardar en cache (1 hora)\n            await self.cache.set(\n                key=cache_key,\n                value=user_locals,\n                ttl=3600\n            )\n\n            return user_locals\n\n        except Exception as e:\n            logger.error(f"Error obteniendo locales de usuario: {e}")\n            # En caso de error, denegar acceso\n            return []\n'})}),"\n",(0,l.jsx)(a.h2,{id:"dependency-injection",children:"Dependency Injection"}),"\n",(0,l.jsx)(a.h3,{id:"dependenciespy",children:(0,l.jsx)(a.code,{children:"dependencies.py"})}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-python",children:'from fastapi import Depends, HTTPException, status\nfrom typing import Optional\n\nfrom app.middlewares.local_validation import LocalValidationMiddleware\nfrom app.clients.auth_client import get_auth_client\nfrom app.cache.redis_client import get_redis_cache\n\n\nasync def get_local_validator(\n    auth_client = Depends(get_auth_client),\n    cache = Depends(get_redis_cache)\n) -> LocalValidationMiddleware:\n    """Dependency para obtener validator de locales."""\n    return LocalValidationMiddleware(auth_client, cache)\n\n\nasync def validate_local_access(\n    local_id: str,\n    request: Request,\n    validator: LocalValidationMiddleware = Depends(get_local_validator)\n) -> str:\n    """\n    Dependency para validar acceso a local espec\xedfico.\n\n    Usage:\n        @app.get("/products")\n        async def get_products(\n            local_id: str = Depends(validate_local_access)\n        ):\n            ...\n    """\n    user_id = request.state.user_id\n    org_id = request.state.organization_id\n\n    has_access = await validator.validate_local_access(\n        user_id=user_id,\n        org_id=org_id,\n        local_id=local_id\n    )\n\n    if not has_access:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail="No tienes acceso a este local"\n        )\n\n    return local_id\n'})}),"\n",(0,l.jsx)(a.h2,{id:"uso-en-endpoints",children:"Uso en Endpoints"}),"\n",(0,l.jsx)(a.h3,{id:"opci\xf3n-1-dependency-en-endpoint",children:"Opci\xf3n 1: Dependency en Endpoint"}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-python",children:'from fastapi import APIRouter, Depends\nfrom app.dependencies import validate_local_access\n\nrouter = APIRouter()\n\n@router.get("/products")\nasync def get_products(\n    local_id: str = Depends(validate_local_access),\n    product_service: ProductService = Depends()\n):\n    """\n    Listar productos de un local.\n\n    El dependency validate_local_access ya verific\xf3 el acceso.\n    """\n    products = await product_service.get_by_local(local_id)\n    return products\n'})}),"\n",(0,l.jsx)(a.h3,{id:"opci\xf3n-2-validaci\xf3n-manual-en-service-layer",children:"Opci\xf3n 2: Validaci\xf3n Manual en Service Layer"}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-python",children:'from app.clients.auth_client import AuthClient\n\nclass ProductService:\n    def __init__(\n        self,\n        product_repo: ProductRepository,\n        auth_client: AuthClient\n    ):\n        self.product_repo = product_repo\n        self.auth_client = auth_client\n\n    async def create_product(\n        self,\n        product_data: ProductCreate,\n        user_id: str,\n        org_id: str\n    ):\n        """Crear producto con validaci\xf3n de local."""\n\n        # Validar local_id si viene en los datos\n        if product_data.local_id:\n            await self._validate_local_access(\n                user_id=user_id,\n                org_id=org_id,\n                local_id=product_data.local_id\n            )\n\n        return await self.product_repo.create(product_data, org_id)\n\n    async def _validate_local_access(\n        self,\n        user_id: str,\n        org_id: str,\n        local_id: str\n    ):\n        """Validar acceso a local."""\n        user_locals = await self.auth_client.get_user_locals(user_id, org_id)\n\n        if local_id not in user_locals:\n            raise HTTPException(\n                status_code=403,\n                detail=f"No tienes acceso al local {local_id}"\n            )\n'})}),"\n",(0,l.jsx)(a.h2,{id:"cache-de-locales",children:"Cache de Locales"}),"\n",(0,l.jsx)(a.h3,{id:"estrategia-de-invalidaci\xf3n",children:"Estrategia de Invalidaci\xf3n"}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-python",children:'class LocalCacheManager:\n    """Gestor de cache para locales."""\n\n    def __init__(self, cache: RedisCache):\n        self.cache = cache\n\n    async def invalidate_user_locals(\n        self,\n        user_id: str,\n        org_id: str\n    ):\n        """Invalidar cache de locales de un usuario."""\n        cache_key = f"locals:{org_id}:{user_id}"\n        await self.cache.delete(cache_key)\n\n    async def invalidate_org_locals(self, org_id: str):\n        """Invalidar cache de todos los usuarios de una org."""\n        pattern = f"locals:{org_id}:*"\n        await self.cache.delete_pattern(pattern)\n'})}),"\n",(0,l.jsx)(a.h3,{id:"sincronizaci\xf3n-con-eventos",children:"Sincronizaci\xf3n con Eventos"}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-python",children:'# En event handlers (eventos-consumidos.md)\n\nasync def handle_local_created(event: dict):\n    """Invalidar cache cuando se crea un local."""\n    org_id = event["payload"]["organization_id"]\n    await cache_manager.invalidate_org_locals(org_id)\n\nasync def handle_user_locals_updated(event: dict):\n    """Invalidar cache cuando cambian locales de usuario."""\n    user_id = event["payload"]["user_id"]\n    org_id = event["payload"]["organization_id"]\n    await cache_manager.invalidate_user_locals(user_id, org_id)\n'})}),"\n",(0,l.jsx)(a.h2,{id:"testing",children:"Testing"}),"\n",(0,l.jsx)(a.h3,{id:"unit-test",children:"Unit Test"}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-python",children:'import pytest\nfrom unittest.mock import Mock, AsyncMock\n\n@pytest.mark.asyncio\nasync def test_validate_local_access_allowed():\n    """Test de validaci\xf3n exitosa de local."""\n\n    # Mock del auth client\n    auth_client = Mock()\n    auth_client.get_user_locals = AsyncMock(\n        return_value=["local-1", "local-2", "local-3"]\n    )\n\n    # Mock del cache\n    cache = Mock()\n    cache.get = AsyncMock(return_value=None)\n    cache.set = AsyncMock()\n\n    # Crear validator\n    validator = LocalValidationMiddleware(auth_client, cache)\n\n    # Validar acceso\n    has_access = await validator.validate_local_access(\n        user_id="user-123",\n        org_id="org-456",\n        local_id="local-2"\n    )\n\n    assert has_access is True\n\n@pytest.mark.asyncio\nasync def test_validate_local_access_denied():\n    """Test de validaci\xf3n denegada."""\n\n    auth_client = Mock()\n    auth_client.get_user_locals = AsyncMock(\n        return_value=["local-1", "local-2"]\n    )\n\n    cache = Mock()\n    cache.get = AsyncMock(return_value=None)\n\n    validator = LocalValidationMiddleware(auth_client, cache)\n\n    has_access = await validator.validate_local_access(\n        user_id="user-123",\n        org_id="org-456",\n        local_id="local-999"  # No est\xe1 en la lista\n    )\n\n    assert has_access is False\n'})}),"\n",(0,l.jsx)(a.h2,{id:"logs-y-monitoreo",children:"Logs y Monitoreo"}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-python",children:'import structlog\n\nlogger = structlog.get_logger()\n\n# Log de acceso permitido\nlogger.info(\n    "local_access_granted",\n    user_id=user_id,\n    organization_id=org_id,\n    local_id=local_id,\n    cache_hit=True\n)\n\n# Log de acceso denegado\nlogger.warning(\n    "local_access_denied",\n    user_id=user_id,\n    organization_id=org_id,\n    local_id=local_id,\n    reason="local_not_in_user_list"\n)\n'})}),"\n",(0,l.jsx)(a.h2,{id:"m\xe9tricas",children:"M\xe9tricas"}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-python",children:'from prometheus_client import Counter, Histogram\n\n# Contador de validaciones\nlocal_validations = Counter(\n    "catalog_local_validations_total",\n    "Total de validaciones de local",\n    ["result"]  # allowed, denied\n)\n\n# Latencia de validaci\xf3n\nlocal_validation_duration = Histogram(\n    "catalog_local_validation_duration_seconds",\n    "Duraci\xf3n de validaciones de local"\n)\n\n# Uso\nwith local_validation_duration.time():\n    has_access = await validate_local_access(...)\n\nif has_access:\n    local_validations.labels(result="allowed").inc()\nelse:\n    local_validations.labels(result="denied").inc()\n'})}),"\n",(0,l.jsx)(a.h2,{id:"pr\xf3ximos-pasos",children:"Pr\xf3ximos Pasos"}),"\n",(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsx)(a.li,{children:(0,l.jsx)(a.a,{href:"/microservicios/catalog-service/auth-client-grpc",children:"Auth Client gRPC"})}),"\n",(0,l.jsx)(a.li,{children:(0,l.jsx)(a.a,{href:"/microservicios/catalog-service/eventos-consumidos",children:"Eventos Consumidos"})}),"\n",(0,l.jsx)(a.li,{children:(0,l.jsx)(a.a,{href:"/microservicios/catalog-service/cache-strategy",children:"Cache Strategy"})}),"\n"]})]})}function _(e={}){const{wrapper:a}={...(0,c.R)(),...e.components};return a?(0,l.jsx)(a,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},8453:(e,a,n)=>{n.d(a,{R:()=>s,x:()=>o});var i=n(6540);const l={},c=i.createContext(l);function s(e){const a=i.useContext(c);return i.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function o(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),i.createElement(c.Provider,{value:a},e.children)}}}]);