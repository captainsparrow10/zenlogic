"use strict";(globalThis.webpackChunkerp_docs=globalThis.webpackChunkerp_docs||[]).push([[3714],{7683:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"microservicios/auth-service/arquitectura","title":"Arquitectura Interna","description":"Capas de la Arquitectura","source":"@site/docs/02-microservicios/auth-service/02-arquitectura.md","sourceDirName":"02-microservicios/auth-service","slug":"/microservicios/auth-service/arquitectura","permalink":"/zenlogic/microservicios/auth-service/arquitectura","draft":false,"unlisted":false,"editUrl":"https://github.com/your-repo/edit/main/docs/02-microservicios/auth-service/02-arquitectura.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"docs","previous":{"title":"Alcance del Auth Service","permalink":"/zenlogic/microservicios/auth-service/alcance"},"next":{"title":"Modelo de Datos","permalink":"/zenlogic/microservicios/auth-service/modelo-datos"}}');var i=r(4848),t=r(8453);const a={sidebar_position:3},o="Arquitectura Interna",c={},l=[{value:"Capas de la Arquitectura",id:"capas-de-la-arquitectura",level:2},{value:"Estructura de Directorios",id:"estructura-de-directorios",level:2},{value:"API Layer",id:"api-layer",level:2},{value:"REST API (FastAPI)",id:"rest-api-fastapi",level:3},{value:"gRPC Server",id:"grpc-server",level:3},{value:"Service Layer",id:"service-layer",level:2},{value:"Auth Service",id:"auth-service",level:3},{value:"Token Service",id:"token-service",level:3},{value:"Repository Layer",id:"repository-layer",level:2},{value:"Infrastructure Layer",id:"infrastructure-layer",level:2},{value:"Event Publisher",id:"event-publisher",level:3},{value:"Cache Manager",id:"cache-manager",level:3},{value:"Dependency Injection",id:"dependency-injection",level:2},{value:"Flujo Completo: Login",id:"flujo-completo-login",level:2},{value:"Pr\xf3ximos Pasos",id:"pr\xf3ximos-pasos",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"arquitectura-interna",children:"Arquitectura Interna"})}),"\n",(0,i.jsx)(n.h2,{id:"capas-de-la-arquitectura",children:"Capas de la Arquitectura"}),"\n",(0,i.jsx)(n.p,{children:"Auth Service implementa una arquitectura en capas (Layered Architecture) con separaci\xf3n clara de responsabilidades."}),"\n",(0,i.jsx)(n.mermaid,{value:'graph TB\n    subgraph "External"\n        Client[Clients<br/>Web/Mobile]\n        Services[Other Microservices]\n    end\n\n    subgraph "Auth Service"\n        direction TB\n\n        subgraph "API Layer"\n            REST[REST API<br/>FastAPI]\n            gRPC[gRPC Server]\n        end\n\n        subgraph "Service Layer"\n            AuthSvc[Auth Service]\n            UserSvc[User Service]\n            RoleSvc[Role Service]\n            PermSvc[Permission Service]\n            OrgSvc[Organization Service]\n            LocalSvc[Local Service]\n            TokenSvc[Token Service]\n        end\n\n        subgraph "Repository Layer"\n            UserRepo[User Repository]\n            RoleRepo[Role Repository]\n            PermRepo[Permission Repository]\n            OrgRepo[Organization Repository]\n            LocalRepo[Local Repository]\n        end\n\n        subgraph "Infrastructure Layer"\n            EventPub[Event Publisher]\n            Cache[Cache Manager]\n            Crypto[Crypto Utils]\n        end\n    end\n\n    subgraph "Data Layer"\n        PG[(PostgreSQL)]\n        Redis[(Redis)]\n        RMQ[RabbitMQ]\n    end\n\n    Client --\x3e|HTTP| REST\n    Services --\x3e|gRPC| gRPC\n\n    REST --\x3e AuthSvc\n    REST --\x3e UserSvc\n    REST --\x3e RoleSvc\n    REST --\x3e OrgSvc\n\n    gRPC --\x3e TokenSvc\n\n    AuthSvc --\x3e UserRepo\n    UserSvc --\x3e UserRepo\n    RoleSvc --\x3e RoleRepo\n    OrgSvc --\x3e OrgRepo\n\n    UserRepo --\x3e PG\n    RoleRepo --\x3e PG\n    OrgRepo --\x3e PG\n\n    AuthSvc --\x3e Cache\n    TokenSvc --\x3e Cache\n    Cache --\x3e Redis\n\n    AuthSvc --\x3e EventPub\n    UserSvc --\x3e EventPub\n    EventPub --\x3e RMQ'}),"\n",(0,i.jsx)(n.h2,{id:"estructura-de-directorios",children:"Estructura de Directorios"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"auth-service/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 api/                    # API Layer\n\u2502   \u2502   \u251c\u2500\u2500 rest/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 auth.py         # Endpoints de autenticaci\xf3n\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 users.py        # CRUD usuarios\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 roles.py        # CRUD roles\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 permissions.py  # Gesti\xf3n permisos\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 organizations.py\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 locals.py\n\u2502   \u2502   \u2514\u2500\u2500 grpc/\n\u2502   \u2502       \u251c\u2500\u2500 __init__.py\n\u2502   \u2502       \u251c\u2500\u2500 server.py       # gRPC server\n\u2502   \u2502       \u2514\u2500\u2500 auth_service.proto\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 services/               # Service Layer\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 auth_service.py     # L\xf3gica de autenticaci\xf3n\n\u2502   \u2502   \u251c\u2500\u2500 user_service.py     # L\xf3gica de usuarios\n\u2502   \u2502   \u251c\u2500\u2500 role_service.py     # L\xf3gica de roles\n\u2502   \u2502   \u251c\u2500\u2500 permission_service.py\n\u2502   \u2502   \u251c\u2500\u2500 organization_service.py\n\u2502   \u2502   \u251c\u2500\u2500 local_service.py\n\u2502   \u2502   \u2514\u2500\u2500 token_service.py    # Generaci\xf3n/validaci\xf3n JWT\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 repositories/           # Repository Layer\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 user_repository.py\n\u2502   \u2502   \u251c\u2500\u2500 role_repository.py\n\u2502   \u2502   \u251c\u2500\u2500 permission_repository.py\n\u2502   \u2502   \u251c\u2500\u2500 organization_repository.py\n\u2502   \u2502   \u2514\u2500\u2500 local_repository.py\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 models/                 # SQLAlchemy Models\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 user.py\n\u2502   \u2502   \u251c\u2500\u2500 role.py\n\u2502   \u2502   \u251c\u2500\u2500 permission.py\n\u2502   \u2502   \u251c\u2500\u2500 organization.py\n\u2502   \u2502   \u2514\u2500\u2500 local.py\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 schemas/                # Pydantic Schemas\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 auth.py             # LoginRequest, TokenResponse\n\u2502   \u2502   \u251c\u2500\u2500 user.py             # UserCreate, UserUpdate, UserResponse\n\u2502   \u2502   \u251c\u2500\u2500 role.py\n\u2502   \u2502   \u251c\u2500\u2500 permission.py\n\u2502   \u2502   \u251c\u2500\u2500 organization.py\n\u2502   \u2502   \u2514\u2500\u2500 local.py\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 infrastructure/         # Infrastructure Layer\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 database.py         # DB connection\n\u2502   \u2502   \u251c\u2500\u2500 redis_client.py     # Redis client\n\u2502   \u2502   \u251c\u2500\u2500 event_publisher.py  # RabbitMQ publisher\n\u2502   \u2502   \u251c\u2500\u2500 crypto.py           # Password hashing, JWT\n\u2502   \u2502   \u2514\u2500\u2500 cache.py            # Cache manager\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 middleware/             # Middlewares\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 auth_middleware.py  # Validaci\xf3n de token\n\u2502   \u2502   \u251c\u2500\u2500 tenant_middleware.py # Validaci\xf3n X-Tenant-ID\n\u2502   \u2502   \u2514\u2500\u2500 rate_limit.py       # Rate limiting\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 dependencies/           # FastAPI Dependencies\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 auth.py             # get_current_user\n\u2502   \u2502   \u251c\u2500\u2500 database.py         # get_db\n\u2502   \u2502   \u2514\u2500\u2500 permissions.py      # require_permission\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 config/                 # Configuraci\xf3n\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 settings.py         # Environment variables\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 main.py                 # Entry point\n\u2502\n\u251c\u2500\u2500 tests/                      # Tests\n\u2502   \u251c\u2500\u2500 unit/\n\u2502   \u251c\u2500\u2500 integration/\n\u2502   \u2514\u2500\u2500 e2e/\n\u2502\n\u251c\u2500\u2500 migrations/                 # Alembic migrations\n\u2502   \u2514\u2500\u2500 versions/\n\u2502\n\u251c\u2500\u2500 scripts/                    # Scripts utilitarios\n\u2502   \u251c\u2500\u2500 seed_permissions.py\n\u2502   \u2514\u2500\u2500 create_admin.py\n\u2502\n\u251c\u2500\u2500 Dockerfile\n\u251c\u2500\u2500 docker-compose.yml\n\u251c\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 pytest.ini\n\u2514\u2500\u2500 README.md\n"})}),"\n",(0,i.jsx)(n.h2,{id:"api-layer",children:"API Layer"}),"\n",(0,i.jsx)(n.h3,{id:"rest-api-fastapi",children:"REST API (FastAPI)"}),"\n",(0,i.jsx)(n.p,{children:"Expone endpoints HTTP para clientes externos."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Archivo"}),": ",(0,i.jsx)(n.code,{children:"src/api/rest/auth.py"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from fastapi import APIRouter, Depends, HTTPException\nfrom src.schemas.auth import LoginRequest, TokenResponse\nfrom src.services.auth_service import AuthService\n\nrouter = APIRouter(prefix="/auth", tags=["Authentication"])\n\n@router.post("/login", response_model=TokenResponse)\nasync def login(\n    credentials: LoginRequest,\n    auth_service: AuthService = Depends()\n):\n    """\n    Autenticar usuario y retornar tokens\n    """\n    try:\n        result = await auth_service.login(\n            credentials.email,\n            credentials.password\n        )\n        return result\n    except InvalidCredentialsError:\n        raise HTTPException(401, "Credenciales inv\xe1lidas")\n'})}),"\n",(0,i.jsx)(n.h3,{id:"grpc-server",children:"gRPC Server"}),"\n",(0,i.jsx)(n.p,{children:"Expone servicios internos para otros microservicios."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Archivo"}),": ",(0,i.jsx)(n.code,{children:"src/api/grpc/auth_service.proto"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:'syntax = "proto3";\n\npackage auth;\n\nservice AuthService {\n  rpc VerifyToken(VerifyTokenRequest) returns (VerifyTokenResponse);\n  rpc GetUserPermissions(GetUserPermissionsRequest) returns (GetUserPermissionsResponse);\n}\n\nmessage VerifyTokenRequest {\n  string token = 1;\n}\n\nmessage VerifyTokenResponse {\n  string user_id = 1;\n  string organization_id = 2;\n  string email = 3;\n  repeated string permissions = 4;\n  repeated string locals = 5;\n  bool active = 6;\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Implementaci\xf3n"}),": ",(0,i.jsx)(n.code,{children:"src/api/grpc/server.py"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import grpc\nfrom concurrent import futures\nfrom src.services.token_service import TokenService\nimport auth_pb2\nimport auth_pb2_grpc\n\nclass AuthServicer(auth_pb2_grpc.AuthServiceServicer):\n    def __init__(self, token_service: TokenService):\n        self.token_service = token_service\n\n    async def VerifyToken(self, request, context):\n        try:\n            user = await self.token_service.verify_token(request.token)\n            return auth_pb2.VerifyTokenResponse(\n                user_id=user.id,\n                organization_id=user.organization_id,\n                email=user.email,\n                permissions=user.permissions,\n                locals=user.locals,\n                active=user.active\n            )\n        except Exception as e:\n            context.set_code(grpc.StatusCode.UNAUTHENTICATED)\n            context.set_details(str(e))\n            return auth_pb2.VerifyTokenResponse()\n\ndef serve():\n    server = grpc.aio.server(futures.ThreadPoolExecutor(max_workers=10))\n    auth_pb2_grpc.add_AuthServiceServicer_to_server(\n        AuthServicer(token_service),\n        server\n    )\n    server.add_insecure_port('[::]:50051')\n    await server.start()\n    await server.wait_for_termination()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"service-layer",children:"Service Layer"}),"\n",(0,i.jsx)(n.p,{children:"Contiene la l\xf3gica de negocio."}),"\n",(0,i.jsx)(n.h3,{id:"auth-service",children:"Auth Service"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Archivo"}),": ",(0,i.jsx)(n.code,{children:"src/services/auth_service.py"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from src.repositories.user_repository import UserRepository\nfrom src.services.token_service import TokenService\nfrom src.infrastructure.crypto import CryptoUtils\nfrom src.infrastructure.event_publisher import EventPublisher\n\nclass AuthService:\n    def __init__(\n        self,\n        user_repo: UserRepository,\n        token_service: TokenService,\n        crypto: CryptoUtils,\n        event_publisher: EventPublisher\n    ):\n        self.user_repo = user_repo\n        self.token_service = token_service\n        self.crypto = crypto\n        self.event_publisher = event_publisher\n\n    async def login(self, email: str, password: str):\n        """\n        Autenticar usuario y generar tokens\n        """\n        # 1. Buscar usuario\n        user = await self.user_repo.get_by_email(email)\n        if not user:\n            raise InvalidCredentialsError("Usuario no encontrado")\n\n        # 2. Validar contrase\xf1a\n        if not self.crypto.verify_password(password, user.password_hash):\n            await self._handle_failed_login(user.id)\n            raise InvalidCredentialsError("Contrase\xf1a incorrecta")\n\n        # 3. Validar usuario activo\n        if not user.active:\n            raise UserInactiveError("Usuario inactivo")\n\n        # 4. Generar tokens\n        access_token = await self.token_service.create_access_token(user)\n        refresh_token = await self.token_service.create_refresh_token(user)\n\n        # 5. Publicar evento\n        await self.event_publisher.publish(\n            "auth.session.created",\n            {\n                "user_id": user.id,\n                "organization_id": user.organization_id,\n                "timestamp": datetime.utcnow().isoformat()\n            }\n        )\n\n        return {\n            "access_token": access_token,\n            "refresh_token": refresh_token,\n            "token_type": "bearer",\n            "expires_in": 900,  # 15 minutos\n            "user": user.to_dict()\n        }\n\n    async def _handle_failed_login(self, user_id: str):\n        """Incrementa intentos fallidos y bloquea si es necesario"""\n        attempts = await self.redis.incr(f"failed_login:{user_id}")\n        await self.redis.expire(f"failed_login:{user_id}", 900)  # 15 min\n\n        if attempts >= 5:\n            await self.user_repo.update(user_id, {"locked": True})\n            await self.event_publisher.publish(\n                "auth.user.locked",\n                {"user_id": user_id, "reason": "too_many_attempts"}\n            )\n'})}),"\n",(0,i.jsx)(n.h3,{id:"token-service",children:"Token Service"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Archivo"}),": ",(0,i.jsx)(n.code,{children:"src/services/token_service.py"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from jose import jwt, JWTError\nfrom datetime import datetime, timedelta\nfrom src.config.settings import settings\n\nclass TokenService:\n    def __init__(self, redis_client, user_repo):\n        self.redis = redis_client\n        self.user_repo = user_repo\n\n    async def create_access_token(self, user) -> str:\n        """\n        Genera Access Token (JWT)\n        """\n        payload = {\n            "user_id": user.id,\n            "email": user.email,\n            "organization_id": user.organization_id,\n            "permissions": user.get_permissions(),\n            "locals": user.get_locals(),\n            "exp": datetime.utcnow() + timedelta(minutes=15),\n            "iat": datetime.utcnow(),\n            "type": "access"\n        }\n\n        token = jwt.encode(\n            payload,\n            settings.JWT_PRIVATE_KEY,\n            algorithm="RS256"\n        )\n\n        # Cachear en Redis\n        await self.redis.setex(\n            f"token:{user.id}",\n            900,  # 15 minutos\n            token\n        )\n\n        return token\n\n    async def verify_token(self, token: str) -> dict:\n        """\n        Valida y decodifica token\n        """\n        # 1. Verificar en blacklist\n        is_blacklisted = await self.redis.exists(f"blacklist:{token}")\n        if is_blacklisted:\n            raise TokenRevokedError("Token revocado")\n\n        # 2. Decodificar y validar firma\n        try:\n            payload = jwt.decode(\n                token,\n                settings.JWT_PUBLIC_KEY,\n                algorithms=["RS256"]\n            )\n        except JWTError as e:\n            raise InvalidTokenError(str(e))\n\n        # 3. Validar expiraci\xf3n\n        exp = payload.get("exp")\n        if datetime.utcnow().timestamp() > exp:\n            raise TokenExpiredError("Token expirado")\n\n        # 4. Obtener usuario actualizado\n        user = await self.user_repo.get_by_id(payload["user_id"])\n        if not user or not user.active:\n            raise UserInactiveError("Usuario inactivo")\n\n        return user\n'})}),"\n",(0,i.jsx)(n.h2,{id:"repository-layer",children:"Repository Layer"}),"\n",(0,i.jsx)(n.p,{children:"Abstrae el acceso a datos."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Archivo"}),": ",(0,i.jsx)(n.code,{children:"src/repositories/user_repository.py"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select\nfrom src.models.user import User\n\nclass UserRepository:\n    def __init__(self, db: AsyncSession):\n        self.db = db\n\n    async def get_by_id(self, user_id: str, org_id: str) -> User:\n        """\n        Obtener usuario por ID (con tenant isolation)\n        """\n        stmt = select(User).where(\n            User.id == user_id,\n            User.organization_id == org_id\n        )\n        result = await self.db.execute(stmt)\n        return result.scalar_one_or_none()\n\n    async def get_by_email(self, email: str, org_id: str) -> User:\n        """\n        Obtener usuario por email\n        """\n        stmt = select(User).where(\n            User.email == email,\n            User.organization_id == org_id\n        )\n        result = await self.db.execute(stmt)\n        return result.scalar_one_or_none()\n\n    async def create(self, user: User) -> User:\n        """\n        Crear nuevo usuario\n        """\n        self.db.add(user)\n        await self.db.commit()\n        await self.db.refresh(user)\n        return user\n\n    async def update(self, user_id: str, org_id: str, data: dict) -> User:\n        """\n        Actualizar usuario\n        """\n        user = await self.get_by_id(user_id, org_id)\n        if not user:\n            raise NotFoundError(f"Usuario {user_id} no encontrado")\n\n        for key, value in data.items():\n            setattr(user, key, value)\n\n        await self.db.commit()\n        await self.db.refresh(user)\n        return user\n'})}),"\n",(0,i.jsx)(n.h2,{id:"infrastructure-layer",children:"Infrastructure Layer"}),"\n",(0,i.jsx)(n.h3,{id:"event-publisher",children:"Event Publisher"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Archivo"}),": ",(0,i.jsx)(n.code,{children:"src/infrastructure/event_publisher.py"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import pika\nimport json\nfrom src.config.settings import settings\n\nclass EventPublisher:\n    def __init__(self):\n        self.connection = pika.BlockingConnection(\n            pika.ConnectionParameters(settings.RABBITMQ_HOST)\n        )\n        self.channel = self.connection.channel()\n        self.channel.exchange_declare(\n            exchange=\'auth_events\',\n            exchange_type=\'topic\',\n            durable=True\n        )\n\n    async def publish(self, event_type: str, payload: dict):\n        """\n        Publica evento a RabbitMQ\n        """\n        message = {\n            "event_type": event_type,\n            "payload": payload,\n            "timestamp": datetime.utcnow().isoformat(),\n            "service": "auth-service"\n        }\n\n        self.channel.basic_publish(\n            exchange=\'auth_events\',\n            routing_key=event_type,\n            body=json.dumps(message),\n            properties=pika.BasicProperties(\n                delivery_mode=2,  # persistent\n                content_type=\'application/json\'\n            )\n        )\n'})}),"\n",(0,i.jsx)(n.h3,{id:"cache-manager",children:"Cache Manager"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Archivo"}),": ",(0,i.jsx)(n.code,{children:"src/infrastructure/cache.py"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import redis.asyncio as redis\nfrom src.config.settings import settings\n\nclass CacheManager:\n    def __init__(self):\n        self.redis = redis.from_url(settings.REDIS_URL)\n\n    async def get(self, key: str):\n        """Obtener valor de cache"""\n        value = await self.redis.get(key)\n        return json.loads(value) if value else None\n\n    async def set(self, key: str, value: any, ttl: int = 300):\n        """Guardar en cache con TTL"""\n        await self.redis.setex(\n            key,\n            ttl,\n            json.dumps(value)\n        )\n\n    async def delete(self, key: str):\n        """Eliminar de cache"""\n        await self.redis.delete(key)\n\n    async def exists(self, key: str) -> bool:\n        """Verificar si existe"""\n        return await self.redis.exists(key) > 0\n'})}),"\n",(0,i.jsx)(n.h2,{id:"dependency-injection",children:"Dependency Injection"}),"\n",(0,i.jsx)(n.p,{children:"FastAPI usa Depends() para inyecci\xf3n de dependencias."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Archivo"}),": ",(0,i.jsx)(n.code,{children:"src/dependencies/auth.py"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from fastapi import Depends, Header, HTTPException\nfrom src.services.token_service import TokenService\n\nasync def get_current_user(\n    authorization: str = Header(...),\n    token_service: TokenService = Depends()\n):\n    """\n    Dependency para obtener usuario actual del token\n    """\n    if not authorization.startswith("Bearer "):\n        raise HTTPException(401, "Token inv\xe1lido")\n\n    token = authorization.replace("Bearer ", "")\n\n    try:\n        user = await token_service.verify_token(token)\n        return user\n    except Exception as e:\n        raise HTTPException(401, str(e))\n\nasync def require_permission(permission: str):\n    """\n    Dependency factory para validar permisos\n    """\n    async def permission_checker(\n        user = Depends(get_current_user)\n    ):\n        if permission not in user.permissions:\n            raise HTTPException(\n                403,\n                f"Se requiere permiso: {permission}"\n            )\n        return user\n\n    return permission_checker\n'})}),"\n",(0,i.jsx)(n.h2,{id:"flujo-completo-login",children:"Flujo Completo: Login"}),"\n",(0,i.jsx)(n.mermaid,{value:'sequenceDiagram\n    participant Client\n    participant REST as REST API\n    participant AuthSvc as Auth Service\n    participant UserRepo as User Repository\n    participant Crypto\n    participant TokenSvc as Token Service\n    participant Cache as Redis\n    participant EventPub as Event Publisher\n    participant DB as PostgreSQL\n    participant MQ as RabbitMQ\n\n    Client->>REST: POST /auth/login<br/>{email, password}\n    REST->>AuthSvc: login(email, password)\n\n    AuthSvc->>UserRepo: get_by_email(email)\n    UserRepo->>DB: SELECT * FROM users WHERE email = ?\n    DB--\x3e>UserRepo: User\n    UserRepo--\x3e>AuthSvc: User\n\n    AuthSvc->>Crypto: verify_password(password, hash)\n    Crypto--\x3e>AuthSvc: valid=True\n\n    AuthSvc->>TokenSvc: create_access_token(user)\n    TokenSvc->>Cache: setex(token_key, token)\n    Cache--\x3e>TokenSvc: OK\n    TokenSvc--\x3e>AuthSvc: access_token\n\n    AuthSvc->>TokenSvc: create_refresh_token(user)\n    TokenSvc--\x3e>AuthSvc: refresh_token\n\n    AuthSvc->>EventPub: publish("auth.session.created", {...})\n    EventPub->>MQ: Publish event\n    MQ--\x3e>EventPub: OK\n\n    AuthSvc--\x3e>REST: {access_token, refresh_token, user}\n    REST--\x3e>Client: 200 OK + tokens'}),"\n",(0,i.jsx)(n.h2,{id:"pr\xf3ximos-pasos",children:"Pr\xf3ximos Pasos"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/microservicios/auth-service/modelo-datos",children:"Modelo de Datos"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/microservicios/auth-service/eventos-publicados",children:"Eventos Publicados"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/microservicios/auth-service/grpc-server",children:"gRPC Server"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var s=r(6540);const i={},t=s.createContext(i);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);