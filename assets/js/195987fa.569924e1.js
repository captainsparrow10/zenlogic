"use strict";(globalThis.webpackChunkerp_docs=globalThis.webpackChunkerp_docs||[]).push([[8955],{4059:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"microservicios/catalog-service/auth-client-grpc","title":"Auth Client gRPC","description":"Cliente gRPC para comunicaci\xf3n con Auth Service con Circuit Breaker y fallback a REST.","source":"@site/docs/02-microservicios/catalog-service/08-auth-client-grpc.md","sourceDirName":"02-microservicios/catalog-service","slug":"/microservicios/catalog-service/auth-client-grpc","permalink":"/zenlogic/microservicios/catalog-service/auth-client-grpc","draft":false,"unlisted":false,"editUrl":"https://github.com/your-repo/edit/main/docs/02-microservicios/catalog-service/08-auth-client-grpc.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"docs","previous":{"title":"Validaci\xf3n de Locales","permalink":"/zenlogic/microservicios/catalog-service/validacion-locales"},"next":{"title":"Products API","permalink":"/zenlogic/microservicios/catalog-service/api-products"}}');var i=t(4848),s=t(8453);const a={sidebar_position:9},c="Auth Client gRPC",o={},l=[{value:"Arquitectura",id:"arquitectura",level:2},{value:"Proto Definitions",id:"proto-definitions",level:2},{value:"<code>protos/auth_service.proto</code>",id:"protosauth_serviceproto",level:3},{value:"Implementaci\xf3n del Cliente",id:"implementaci\xf3n-del-cliente",level:2},{value:"<code>clients/auth_client.py</code>",id:"clientsauth_clientpy",level:3},{value:"Dependency Injection",id:"dependency-injection",level:2},{value:"Retry Logic",id:"retry-logic",level:2},{value:"Testing",id:"testing",level:2},{value:"Pr\xf3ximos Pasos",id:"pr\xf3ximos-pasos",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"auth-client-grpc",children:"Auth Client gRPC"})}),"\n",(0,i.jsx)(n.p,{children:"Cliente gRPC para comunicaci\xf3n con Auth Service con Circuit Breaker y fallback a REST."}),"\n",(0,i.jsx)(n.h2,{id:"arquitectura",children:"Arquitectura"}),"\n",(0,i.jsx)(n.mermaid,{value:"graph TD\n    CatalogService[Catalog Service]\n    AuthClient[Auth gRPC Client]\n    CircuitBreaker[Circuit Breaker]\n    gRPC[Auth gRPC Server:50051]\n    REST[Auth REST API:8001]\n    Cache[Redis Cache]\n\n    CatalogService --\x3e|1. Request| AuthClient\n    AuthClient --\x3e|2. Check| CircuitBreaker\n    CircuitBreaker --\x3e|3a. Open| gRPC\n    CircuitBreaker --\x3e|3b. Closed/Fallback| REST\n    AuthClient --\x3e|4. Cache| Cache"}),"\n",(0,i.jsx)(n.h2,{id:"proto-definitions",children:"Proto Definitions"}),"\n",(0,i.jsx)(n.h3,{id:"protosauth_serviceproto",children:(0,i.jsx)(n.code,{children:"protos/auth_service.proto"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",children:'syntax = "proto3";\n\npackage auth;\n\nservice AuthService {\n  rpc VerifyToken(VerifyTokenRequest) returns (VerifyTokenResponse);\n  rpc GetUserPermissions(GetUserPermissionsRequest) returns (GetUserPermissionsResponse);\n  rpc GetUserLocals(GetUserLocalsRequest) returns (GetUserLocalsResponse);\n  rpc GetOrganization(GetOrganizationRequest) returns (GetOrganizationResponse);\n}\n\nmessage VerifyTokenRequest {\n  string token = 1;\n}\n\nmessage VerifyTokenResponse {\n  string user_id = 1;\n  string organization_id = 2;\n  string email = 3;\n  bool is_active = 4;\n  repeated string permissions = 5;\n  repeated string locals = 6;\n}\n\nmessage GetUserPermissionsRequest {\n  string user_id = 1;\n  string organization_id = 2;\n}\n\nmessage GetUserPermissionsResponse {\n  repeated string permissions = 1;\n}\n\nmessage GetUserLocalsRequest {\n  string user_id = 1;\n  string organization_id = 2;\n}\n\nmessage GetUserLocalsResponse {\n  repeated string local_ids = 1;\n}\n\nmessage GetOrganizationRequest {\n  string organization_id = 1;\n}\n\nmessage GetOrganizationResponse {\n  string id = 1;\n  string name = 2;\n  string plan = 3;\n  bool is_active = 4;\n  repeated string modules = 5;\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"implementaci\xf3n-del-cliente",children:"Implementaci\xf3n del Cliente"}),"\n",(0,i.jsx)(n.h3,{id:"clientsauth_clientpy",children:(0,i.jsx)(n.code,{children:"clients/auth_client.py"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import grpc\nimport httpx\nfrom typing import List, Optional\nfrom datetime import datetime, timedelta\nimport logging\n\nfrom protos import auth_service_pb2, auth_service_pb2_grpc\nfrom config.settings import settings\nfrom app.cache.redis_client import RedisCache\n\nlogger = logging.getLogger(__name__)\n\n\nclass CircuitBreaker:\n    """Circuit Breaker para gRPC."""\n\n    def __init__(\n        self,\n        failure_threshold: int = 5,\n        timeout: int = 60,\n        recovery_timeout: int = 30\n    ):\n        self.failure_threshold = failure_threshold\n        self.timeout = timeout\n        self.recovery_timeout = recovery_timeout\n        self.failures = 0\n        self.last_failure_time = None\n        self.state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN\n\n    def call(self, func):\n        """Ejecutar funci\xf3n con circuit breaker."""\n        if self.state == "OPEN":\n            # Verificar si es hora de intentar recuperaci\xf3n\n            if datetime.now() - self.last_failure_time > timedelta(\n                seconds=self.recovery_timeout\n            ):\n                self.state = "HALF_OPEN"\n                logger.info("Circuit Breaker: HALF_OPEN - intentando recuperaci\xf3n")\n            else:\n                raise Exception("Circuit Breaker is OPEN")\n\n        try:\n            result = func()\n            # \xc9xito - resetear contador\n            if self.state == "HALF_OPEN":\n                self.state = "CLOSED"\n                logger.info("Circuit Breaker: CLOSED - recuperado")\n            self.failures = 0\n            return result\n\n        except Exception as e:\n            self.failures += 1\n            self.last_failure_time = datetime.now()\n\n            if self.failures >= self.failure_threshold:\n                self.state = "OPEN"\n                logger.error(f"Circuit Breaker: OPEN - {self.failures} fallos")\n\n            raise\n\n\nclass AuthClient:\n    """Cliente para comunicaci\xf3n con Auth Service."""\n\n    def __init__(self, cache: RedisCache):\n        self.cache = cache\n        self.grpc_channel = None\n        self.grpc_stub = None\n        self.circuit_breaker = CircuitBreaker(\n            failure_threshold=settings.circuit_breaker_failure_threshold,\n            timeout=settings.circuit_breaker_timeout,\n            recovery_timeout=settings.circuit_breaker_recovery_timeout\n        )\n        self._setup_grpc()\n\n    def _setup_grpc(self):\n        """Configurar canal gRPC."""\n        grpc_address = f"{settings.auth_grpc_host}:{settings.auth_grpc_port}"\n        self.grpc_channel = grpc.aio.insecure_channel(grpc_address)\n        self.grpc_stub = auth_service_pb2_grpc.AuthServiceStub(self.grpc_channel)\n\n    async def verify_token(self, token: str) -> dict:\n        """Verificar token JWT."""\n        cache_key = f"token_verify:{token[:20]}"\n\n        # Intentar cache\n        cached = await self.cache.get(cache_key)\n        if cached:\n            return cached\n\n        try:\n            # Intentar gRPC\n            result = await self._verify_token_grpc(token)\n        except Exception as e:\n            logger.warning(f"gRPC failed, usando REST fallback: {e}")\n            result = await self._verify_token_rest(token)\n\n        # Guardar en cache (5 minutos)\n        await self.cache.set(cache_key, result, ttl=300)\n        return result\n\n    async def _verify_token_grpc(self, token: str) -> dict:\n        """Verificar token v\xeda gRPC."""\n        request = auth_service_pb2.VerifyTokenRequest(token=token)\n\n        def call():\n            return self.grpc_stub.VerifyToken(\n                request,\n                timeout=settings.auth_grpc_timeout\n            )\n\n        response = await self.circuit_breaker.call(call)\n\n        return {\n            "user_id": response.user_id,\n            "organization_id": response.organization_id,\n            "email": response.email,\n            "is_active": response.is_active,\n            "permissions": list(response.permissions),\n            "locals": list(response.locals)\n        }\n\n    async def _verify_token_rest(self, token: str) -> dict:\n        """Verificar token v\xeda REST (fallback)."""\n        async with httpx.AsyncClient() as client:\n            response = await client.post(\n                f"{settings.auth_rest_url}/auth/verify",\n                json={"token": token},\n                timeout=settings.auth_rest_timeout\n            )\n            response.raise_for_status()\n            return response.json()\n\n    async def get_user_locals(\n        self,\n        user_id: str,\n        org_id: str\n    ) -> List[str]:\n        """Obtener locales del usuario."""\n        cache_key = f"locals:{org_id}:{user_id}"\n\n        # Intentar cache\n        cached = await self.cache.get(cache_key)\n        if cached:\n            return cached\n\n        try:\n            # Intentar gRPC\n            locals = await self._get_user_locals_grpc(user_id, org_id)\n        except Exception as e:\n            logger.warning(f"gRPC failed, usando REST fallback: {e}")\n            locals = await self._get_user_locals_rest(user_id, org_id)\n\n        # Guardar en cache (1 hora)\n        await self.cache.set(cache_key, locals, ttl=3600)\n        return locals\n\n    async def _get_user_locals_grpc(\n        self,\n        user_id: str,\n        org_id: str\n    ) -> List[str]:\n        """Obtener locales v\xeda gRPC."""\n        request = auth_service_pb2.GetUserLocalsRequest(\n            user_id=user_id,\n            organization_id=org_id\n        )\n\n        def call():\n            return self.grpc_stub.GetUserLocals(\n                request,\n                timeout=settings.auth_grpc_timeout\n            )\n\n        response = await self.circuit_breaker.call(call)\n        return list(response.local_ids)\n\n    async def _get_user_locals_rest(\n        self,\n        user_id: str,\n        org_id: str\n    ) -> List[str]:\n        """Obtener locales v\xeda REST (fallback)."""\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                f"{settings.auth_rest_url}/api/v1/users/{user_id}/locals",\n                headers={"X-Tenant-ID": org_id},\n                timeout=settings.auth_rest_timeout\n            )\n            response.raise_for_status()\n            data = response.json()\n            return [local["id"] for local in data["locals"]]\n\n    async def close(self):\n        """Cerrar canal gRPC."""\n        if self.grpc_channel:\n            await self.grpc_channel.close()\n'})}),"\n",(0,i.jsx)(n.h2,{id:"dependency-injection",children:"Dependency Injection"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from functools import lru_cache\nfrom app.cache.redis_client import get_redis_cache\n\n@lru_cache()\ndef get_auth_client(cache: RedisCache = Depends(get_redis_cache)) -> AuthClient:\n    """Dependency para obtener Auth Client."""\n    return AuthClient(cache)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"retry-logic",children:"Retry Logic"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from tenacity import retry, stop_after_attempt, wait_exponential\n\n@retry(\n    stop=stop_after_attempt(3),\n    wait=wait_exponential(multiplier=1, min=2, max=10)\n)\nasync def verify_token_with_retry(auth_client: AuthClient, token: str):\n    """Verificar token con reintentos."""\n    return await auth_client.verify_token(token)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import pytest\nfrom unittest.mock import Mock, AsyncMock, patch\n\n@pytest.mark.asyncio\nasync def test_verify_token_grpc_success():\n    """Test de verificaci\xf3n de token exitosa v\xeda gRPC."""\n    cache = Mock()\n    cache.get = AsyncMock(return_value=None)\n    cache.set = AsyncMock()\n\n    client = AuthClient(cache)\n\n    # Mock gRPC response\n    mock_response = Mock()\n    mock_response.user_id = "user-123"\n    mock_response.organization_id = "org-456"\n    mock_response.is_active = True\n\n    with patch.object(client.grpc_stub, \'VerifyToken\', return_value=mock_response):\n        result = await client.verify_token("token-abc")\n\n    assert result["user_id"] == "user-123"\n    assert result["organization_id"] == "org-456"\n\n@pytest.mark.asyncio\nasync def test_verify_token_fallback_to_rest():\n    """Test de fallback a REST cuando gRPC falla."""\n    cache = Mock()\n    cache.get = AsyncMock(return_value=None)\n\n    client = AuthClient(cache)\n\n    # Simular fallo de gRPC\n    with patch.object(client.grpc_stub, \'VerifyToken\', side_effect=Exception("gRPC error")):\n        # Mock REST response\n        with patch(\'httpx.AsyncClient.post\') as mock_post:\n            mock_post.return_value.json.return_value = {"user_id": "user-123"}\n            result = await client.verify_token("token-abc")\n\n    assert result["user_id"] == "user-123"\n'})}),"\n",(0,i.jsx)(n.h2,{id:"pr\xf3ximos-pasos",children:"Pr\xf3ximos Pasos"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/microservicios/catalog-service/validacion-locales",children:"Validaci\xf3n de Locales"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/microservicios/catalog-service/api-products",children:"API Products"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/microservicios/catalog-service/cache-strategy",children:"Cache Strategy"})}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var r=t(6540);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);