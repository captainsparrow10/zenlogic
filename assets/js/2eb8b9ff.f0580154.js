"use strict";(globalThis.webpackChunkerp_docs=globalThis.webpackChunkerp_docs||[]).push([[6977],{4073:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>_,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"resiliencia/error-handling-retry","title":"Error Handling y Retry Policies","description":"Estrategias completas de manejo de errores y pol\xedticas de reintentos para resiliencia de microservicios.","source":"@site/docs/07-resiliencia/01-error-handling-retry.md","sourceDirName":"07-resiliencia","slug":"/resiliencia/error-handling-retry","permalink":"/zenlogic/resiliencia/error-handling-retry","draft":false,"unlisted":false,"editUrl":"https://github.com/your-repo/edit/main/docs/07-resiliencia/01-error-handling-retry.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1}}');var i=r(4848),a=r(8453);const o={sidebar_position:1},s="Error Handling y Retry Policies",c={},d=[{value:"Arquitectura de Resiliencia",id:"arquitectura-de-resiliencia",level:2},{value:"1. Jerarqu\xeda de Excepciones",id:"1-jerarqu\xeda-de-excepciones",level:2},{value:"Base Exception Classes",id:"base-exception-classes",level:3},{value:"Business Logic Exceptions",id:"business-logic-exceptions",level:3},{value:"Infrastructure Exceptions",id:"infrastructure-exceptions",level:3},{value:"2. Exception Handler Middleware",id:"2-exception-handler-middleware",level:2},{value:"3. Retry Policies",id:"3-retry-policies",level:2},{value:"Retry Decorator con Tenacity",id:"retry-decorator-con-tenacity",level:3},{value:"Uso de Retry Policies",id:"uso-de-retry-policies",level:3},{value:"4. Circuit Breaker",id:"4-circuit-breaker",level:2},{value:"Implementaci\xf3n con pybreaker",id:"implementaci\xf3n-con-pybreaker",level:3},{value:"Uso de Circuit Breaker",id:"uso-de-circuit-breaker",level:3},{value:"5. Timeouts",id:"5-timeouts",level:2},{value:"Configuraci\xf3n de Timeouts",id:"configuraci\xf3n-de-timeouts",level:3},{value:"Aplicar Timeouts",id:"aplicar-timeouts",level:3},{value:"6. Graceful Degradation",id:"6-graceful-degradation",level:2},{value:"Fallback Strategies",id:"fallback-strategies",level:3},{value:"Cache como Fallback",id:"cache-como-fallback",level:3},{value:"7. Dead Letter Queue",id:"7-dead-letter-queue",level:2},{value:"Configuraci\xf3n DLQ",id:"configuraci\xf3n-dlq",level:3},{value:"Consumer con DLQ",id:"consumer-con-dlq",level:3},{value:"Pr\xf3ximos Pasos",id:"pr\xf3ximos-pasos",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"error-handling-y-retry-policies",children:"Error Handling y Retry Policies"})}),"\n",(0,i.jsx)(n.p,{children:"Estrategias completas de manejo de errores y pol\xedticas de reintentos para resiliencia de microservicios."}),"\n",(0,i.jsx)(n.h2,{id:"arquitectura-de-resiliencia",children:"Arquitectura de Resiliencia"}),"\n",(0,i.jsx)(n.mermaid,{value:'graph TB\n    subgraph "Client Request"\n        REQ[HTTP Request]\n    end\n\n    subgraph "Resilience Layers"\n        TO[Timeout]\n        RT[Retry Policy]\n        CB[Circuit Breaker]\n        FB[Fallback]\n    end\n\n    subgraph "Error Types"\n        T[Transient<br/>Retriable]\n        P[Permanent<br/>Non-retriable]\n    end\n\n    REQ --\x3e TO\n    TO --\x3e RT\n    RT --\x3e CB\n    CB --\x3e T\n    CB --\x3e P\n    T --\x3e RT\n    P --\x3e FB\n\n    style T fill:#90EE90\n    style P fill:#FF6B6B'}),"\n",(0,i.jsx)(n.h2,{id:"1-jerarqu\xeda-de-excepciones",children:"1. Jerarqu\xeda de Excepciones"}),"\n",(0,i.jsx)(n.h3,{id:"base-exception-classes",children:"Base Exception Classes"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# src/exceptions/base.py\nfrom typing import Optional, Dict, Any\n\nclass ERPException(Exception):\n    """Excepci\xf3n base para todo el sistema ERP."""\n\n    def __init__(\n        self,\n        message: str,\n        code: str,\n        status_code: int = 500,\n        details: Optional[Dict[str, Any]] = None\n    ):\n        self.message = message\n        self.code = code\n        self.status_code = status_code\n        self.details = details or {}\n        super().__init__(self.message)\n\n    def to_dict(self) -> Dict[str, Any]:\n        """Convertir excepci\xf3n a diccionario para respuesta."""\n        return {\n            "error": {\n                "code": self.code,\n                "message": self.message,\n                "details": self.details\n            }\n        }\n\nclass ValidationError(ERPException):\n    """Error de validaci\xf3n de datos."""\n\n    def __init__(self, message: str, field: Optional[str] = None):\n        super().__init__(\n            message=message,\n            code="VALIDATION_ERROR",\n            status_code=422,\n            details={"field": field} if field else {}\n        )\n\nclass NotFoundError(ERPException):\n    """Recurso no encontrado."""\n\n    def __init__(self, resource: str, resource_id: str):\n        super().__init__(\n            message=f"{resource} not found",\n            code="NOT_FOUND",\n            status_code=404,\n            details={\n                "resource": resource,\n                "resource_id": resource_id\n            }\n        )\n\nclass ConflictError(ERPException):\n    """Conflicto de estado (e.g., duplicado)."""\n\n    def __init__(self, message: str, conflicting_field: Optional[str] = None):\n        super().__init__(\n            message=message,\n            code="CONFLICT",\n            status_code=409,\n            details={"conflicting_field": conflicting_field}\n        )\n\nclass UnauthorizedError(ERPException):\n    """Error de autenticaci\xf3n."""\n\n    def __init__(self, message: str = "Authentication required"):\n        super().__init__(\n            message=message,\n            code="UNAUTHORIZED",\n            status_code=401\n        )\n\nclass ForbiddenError(ERPException):\n    """Error de autorizaci\xf3n."""\n\n    def __init__(self, message: str = "Access forbidden"):\n        super().__init__(\n            message=message,\n            code="FORBIDDEN",\n            status_code=403\n        )\n'})}),"\n",(0,i.jsx)(n.h3,{id:"business-logic-exceptions",children:"Business Logic Exceptions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# src/exceptions/business.py\nfrom src.exceptions.base import ERPException\n\nclass InsufficientStockError(ERPException):\n    """Stock insuficiente para operaci\xf3n."""\n\n    def __init__(\n        self,\n        variant_id: str,\n        requested: int,\n        available: int\n    ):\n        super().__init__(\n            message=f"Insufficient stock for variant {variant_id}",\n            code="INSUFFICIENT_STOCK",\n            status_code=409,\n            details={\n                "variant_id": variant_id,\n                "requested": requested,\n                "available": available,\n                "shortage": requested - available\n            }\n        )\n        self.variant_id = variant_id\n        self.requested = requested\n        self.available = available\n\nclass ReservationExpiredError(ERPException):\n    """Reserva de stock expirada."""\n\n    def __init__(self, reservation_id: str, expired_at: str):\n        super().__init__(\n            message=f"Reservation {reservation_id} has expired",\n            code="RESERVATION_EXPIRED",\n            status_code=409,\n            details={\n                "reservation_id": reservation_id,\n                "expired_at": expired_at\n            }\n        )\n\nclass PaymentFailedError(ERPException):\n    """Fallo en procesamiento de pago."""\n\n    def __init__(self, reason: str, gateway_error: Optional[str] = None):\n        super().__init__(\n            message=f"Payment failed: {reason}",\n            code="PAYMENT_FAILED",\n            status_code=402,\n            details={\n                "reason": reason,\n                "gateway_error": gateway_error\n            }\n        )\n\nclass InvalidStateTransitionError(ERPException):\n    """Transici\xf3n de estado inv\xe1lida."""\n\n    def __init__(\n        self,\n        resource: str,\n        current_state: str,\n        target_state: str\n    ):\n        super().__init__(\n            message=f"Cannot transition {resource} from {current_state} to {target_state}",\n            code="INVALID_STATE_TRANSITION",\n            status_code=409,\n            details={\n                "resource": resource,\n                "current_state": current_state,\n                "target_state": target_state\n            }\n        )\n\nclass DuplicateSKUError(ConflictError):\n    """SKU duplicado."""\n\n    def __init__(self, sku: str):\n        super().__init__(\n            message=f"SKU \'{sku}\' already exists",\n            conflicting_field="sku"\n        )\n        self.details["sku"] = sku\n'})}),"\n",(0,i.jsx)(n.h3,{id:"infrastructure-exceptions",children:"Infrastructure Exceptions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# src/exceptions/infrastructure.py\nfrom src.exceptions.base import ERPException\n\nclass DatabaseError(ERPException):\n    """Error de base de datos."""\n\n    def __init__(self, operation: str, original_error: str):\n        super().__init__(\n            message=f"Database error during {operation}",\n            code="DATABASE_ERROR",\n            status_code=500,\n            details={\n                "operation": operation,\n                "original_error": original_error\n            }\n        )\n\nclass CacheError(ERPException):\n    """Error de cache (Redis)."""\n\n    def __init__(self, operation: str, original_error: str):\n        super().__init__(\n            message=f"Cache error during {operation}",\n            code="CACHE_ERROR",\n            status_code=500,\n            details={\n                "operation": operation,\n                "original_error": original_error\n            }\n        )\n\nclass EventPublishError(ERPException):\n    """Error al publicar evento."""\n\n    def __init__(self, event_type: str, original_error: str):\n        super().__init__(\n            message=f"Failed to publish event {event_type}",\n            code="EVENT_PUBLISH_ERROR",\n            status_code=500,\n            details={\n                "event_type": event_type,\n                "original_error": original_error\n            }\n        )\n\nclass ExternalServiceError(ERPException):\n    """Error en servicio externo."""\n\n    def __init__(\n        self,\n        service: str,\n        operation: str,\n        status_code: Optional[int] = None,\n        response_body: Optional[str] = None\n    ):\n        super().__init__(\n            message=f"External service {service} failed during {operation}",\n            code="EXTERNAL_SERVICE_ERROR",\n            status_code=502,\n            details={\n                "service": service,\n                "operation": operation,\n                "upstream_status_code": status_code,\n                "response_body": response_body\n            }\n        )\n\nclass CircuitBreakerOpenError(ERPException):\n    """Circuit breaker abierto."""\n\n    def __init__(self, service: str):\n        super().__init__(\n            message=f"Circuit breaker open for {service}",\n            code="CIRCUIT_BREAKER_OPEN",\n            status_code=503,\n            details={"service": service}\n        )\n'})}),"\n",(0,i.jsx)(n.h2,{id:"2-exception-handler-middleware",children:"2. Exception Handler Middleware"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# src/middleware/exception_handler.py\nfrom fastapi import Request, status\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\nfrom starlette.exceptions import HTTPException as StarletteHTTPException\nimport structlog\nfrom src.exceptions.base import ERPException\nfrom sqlalchemy.exc import IntegrityError, OperationalError\n\nlogger = structlog.get_logger(__name__)\n\nasync def erp_exception_handler(request: Request, exc: ERPException):\n    """Handler para excepciones de negocio."""\n\n    logger.warning(\n        "business_exception",\n        error_code=exc.code,\n        error_message=exc.message,\n        path=request.url.path,\n        details=exc.details\n    )\n\n    return JSONResponse(\n        status_code=exc.status_code,\n        content=exc.to_dict()\n    )\n\nasync def validation_exception_handler(\n    request: Request,\n    exc: RequestValidationError\n):\n    """Handler para errores de validaci\xf3n de Pydantic."""\n\n    errors = []\n    for error in exc.errors():\n        errors.append({\n            "field": ".".join(str(loc) for loc in error["loc"]),\n            "message": error["msg"],\n            "type": error["type"]\n        })\n\n    logger.warning(\n        "validation_error",\n        path=request.url.path,\n        errors=errors\n    )\n\n    return JSONResponse(\n        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n        content={\n            "error": {\n                "code": "VALIDATION_ERROR",\n                "message": "Request validation failed",\n                "details": {"errors": errors}\n            }\n        }\n    )\n\nasync def integrity_error_handler(request: Request, exc: IntegrityError):\n    """Handler para errores de integridad de BD."""\n\n    logger.error(\n        "database_integrity_error",\n        path=request.url.path,\n        error=str(exc.orig),\n        exc_info=True\n    )\n\n    # Intentar determinar la causa\n    error_msg = str(exc.orig).lower()\n\n    if "duplicate key" in error_msg or "unique constraint" in error_msg:\n        return JSONResponse(\n            status_code=status.HTTP_409_CONFLICT,\n            content={\n                "error": {\n                    "code": "DUPLICATE_RESOURCE",\n                    "message": "Resource already exists",\n                    "details": {"db_error": str(exc.orig)}\n                }\n            }\n        )\n\n    if "foreign key" in error_msg:\n        return JSONResponse(\n            status_code=status.HTTP_409_CONFLICT,\n            content={\n                "error": {\n                    "code": "INVALID_REFERENCE",\n                    "message": "Referenced resource does not exist",\n                    "details": {"db_error": str(exc.orig)}\n                }\n            }\n        )\n\n    # Error gen\xe9rico de integridad\n    return JSONResponse(\n        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n        content={\n            "error": {\n                "code": "DATABASE_ERROR",\n                "message": "Database integrity error"\n            }\n        }\n    )\n\nasync def operational_error_handler(request: Request, exc: OperationalError):\n    """Handler para errores operacionales de BD."""\n\n    logger.error(\n        "database_operational_error",\n        path=request.url.path,\n        error=str(exc.orig),\n        exc_info=True\n    )\n\n    return JSONResponse(\n        status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n        content={\n            "error": {\n                "code": "DATABASE_UNAVAILABLE",\n                "message": "Database is temporarily unavailable"\n            }\n        }\n    )\n\nasync def generic_exception_handler(request: Request, exc: Exception):\n    """Handler gen\xe9rico para excepciones no capturadas."""\n\n    logger.error(\n        "unhandled_exception",\n        path=request.url.path,\n        error=str(exc),\n        error_type=type(exc).__name__,\n        exc_info=True\n    )\n\n    return JSONResponse(\n        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n        content={\n            "error": {\n                "code": "INTERNAL_ERROR",\n                "message": "An internal error occurred"\n            }\n        }\n    )\n\n# Registrar handlers en FastAPI\ndef register_exception_handlers(app):\n    """Registrar todos los exception handlers."""\n\n    app.add_exception_handler(ERPException, erp_exception_handler)\n    app.add_exception_handler(RequestValidationError, validation_exception_handler)\n    app.add_exception_handler(IntegrityError, integrity_error_handler)\n    app.add_exception_handler(OperationalError, operational_error_handler)\n    app.add_exception_handler(Exception, generic_exception_handler)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"3-retry-policies",children:"3. Retry Policies"}),"\n",(0,i.jsx)(n.h3,{id:"retry-decorator-con-tenacity",children:"Retry Decorator con Tenacity"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# src/retry.py\nfrom tenacity import (\n    retry,\n    stop_after_attempt,\n    wait_exponential,\n    retry_if_exception_type,\n    retry_if_exception,\n    before_sleep_log,\n    after_log\n)\nimport structlog\nfrom typing import Callable\n\nlogger = structlog.get_logger(__name__)\n\n# Determinar si excepci\xf3n es retriable\ndef is_retriable_error(exception: Exception) -> bool:\n    """Determinar si error es retriable."""\n\n    # Errores de red/timeout siempre retriables\n    if isinstance(exception, (\n        ConnectionError,\n        TimeoutError,\n        OSError\n    )):\n        return True\n\n    # Errores de BD transitorios\n    from sqlalchemy.exc import OperationalError, DBAPIError\n    if isinstance(exception, (OperationalError, DBAPIError)):\n        return True\n\n    # Errores de cache\n    from src.exceptions.infrastructure import CacheError\n    if isinstance(exception, CacheError):\n        return True\n\n    # Errores HTTP 5xx (server errors)\n    if hasattr(exception, \'status_code\'):\n        return 500 <= exception.status_code < 600\n\n    return False\n\n# Retry policy para operaciones de BD\nretry_database = retry(\n    stop=stop_after_attempt(3),\n    wait=wait_exponential(multiplier=1, min=1, max=10),\n    retry=retry_if_exception(is_retriable_error),\n    before_sleep=before_sleep_log(logger, logging.WARNING),\n    after=after_log(logger, logging.INFO)\n)\n\n# Retry policy para llamadas externas\nretry_external_call = retry(\n    stop=stop_after_attempt(5),\n    wait=wait_exponential(multiplier=2, min=2, max=60),\n    retry=retry_if_exception(is_retriable_error),\n    before_sleep=before_sleep_log(logger, logging.WARNING)\n)\n\n# Retry policy para eventos\nretry_event_publish = retry(\n    stop=stop_after_attempt(3),\n    wait=wait_exponential(multiplier=1, min=1, max=5),\n    retry=retry_if_exception_type((\n        ConnectionError,\n        TimeoutError\n    )),\n    before_sleep=before_sleep_log(logger, logging.WARNING)\n)\n\n# Retry policy para cache\nretry_cache = retry(\n    stop=stop_after_attempt(2),\n    wait=wait_exponential(multiplier=0.5, min=0.5, max=2),\n    retry=retry_if_exception_type((\n        ConnectionError,\n        TimeoutError\n    ))\n)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"uso-de-retry-policies",children:"Uso de Retry Policies"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# src/services/product_service.py\nfrom src.retry import retry_database, retry_cache, retry_event_publish\nimport structlog\n\nlogger = structlog.get_logger(__name__)\n\nclass ProductService:\n    """Servicio con retry policies."""\n\n    @retry_database\n    async def get_product(\n        self,\n        product_id: str,\n        organization_id: str\n    ) -> Product:\n        """Obtener producto con retry en BD."""\n\n        logger.info(\n            "fetching_product",\n            product_id=product_id,\n            organization_id=organization_id\n        )\n\n        # Esta operaci\xf3n se reintentar\xe1 autom\xe1ticamente\n        # si hay errores transitorios de BD\n        product = await self.repo.get_by_id(\n            product_id,\n            organization_id\n        )\n\n        if not product:\n            raise NotFoundError("Product", product_id)\n\n        return product\n\n    async def create_product(\n        self,\n        organization_id: str,\n        product_data: dict\n    ) -> Product:\n        """Crear producto con retry en operaciones fallibles."""\n\n        # 1. DB operation con retry\n        product = await self._create_in_database(organization_id, product_data)\n\n        # 2. Cache invalidation con retry\n        await self._invalidate_cache(organization_id)\n\n        # 3. Event publishing con retry\n        await self._publish_product_created_event(product)\n\n        return product\n\n    @retry_database\n    async def _create_in_database(\n        self,\n        organization_id: str,\n        product_data: dict\n    ) -> Product:\n        """Crear producto en BD con retry."""\n        return await self.repo.create({\n            **product_data,\n            "organization_id": organization_id\n        })\n\n    @retry_cache\n    async def _invalidate_cache(self, organization_id: str) -> None:\n        """Invalidar cache con retry."""\n        try:\n            await self.cache.invalidate_pattern(f"org:{organization_id}:products:*")\n        except Exception as e:\n            # Si cache falla despu\xe9s de retries, log pero no fallar\n            logger.warning(\n                "cache_invalidation_failed",\n                organization_id=organization_id,\n                error=str(e)\n            )\n\n    @retry_event_publish\n    async def _publish_product_created_event(self, product: Product) -> None:\n        """Publicar evento con retry."""\n        await self.event_publisher.publish(\n            exchange="catalog.events",\n            routing_key="product.created",\n            event=ProductCreatedEvent.from_orm(product)\n        )\n'})}),"\n",(0,i.jsx)(n.h2,{id:"4-circuit-breaker",children:"4. Circuit Breaker"}),"\n",(0,i.jsx)(n.h3,{id:"implementaci\xf3n-con-pybreaker",children:"Implementaci\xf3n con pybreaker"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# src/circuit_breaker.py\nfrom pybreaker import CircuitBreaker, CircuitBreakerError\nimport structlog\nfrom typing import Callable\n\nlogger = structlog.get_logger(__name__)\n\n# Circuit breaker para llamadas gRPC a Inventory\ninventory_circuit_breaker = CircuitBreaker(\n    fail_max=5,  # Abrir despu\xe9s de 5 fallos\n    reset_timeout=60,  # Intentar cerrar despu\xe9s de 60s\n    exclude=[\n        # No contar estos errores\n        NotFoundError,\n        ValidationError\n    ],\n    name="inventory_grpc"\n)\n\n# Circuit breaker para llamadas a Stripe\npayment_gateway_circuit_breaker = CircuitBreaker(\n    fail_max=3,\n    reset_timeout=120,\n    name="stripe_api"\n)\n\n# Circuit breaker para base de datos\ndatabase_circuit_breaker = CircuitBreaker(\n    fail_max=10,\n    reset_timeout=30,\n    name="database"\n)\n\n# Listeners para logging\ndef on_circuit_open(breaker, error):\n    """Callback cuando circuit se abre."""\n    logger.error(\n        "circuit_breaker_opened",\n        breaker_name=breaker.name,\n        error=str(error)\n    )\n\ndef on_circuit_close(breaker):\n    """Callback cuando circuit se cierra."""\n    logger.info(\n        "circuit_breaker_closed",\n        breaker_name=breaker.name\n    )\n\ndef on_circuit_half_open(breaker):\n    """Callback cuando circuit entra en half-open."""\n    logger.warning(\n        "circuit_breaker_half_open",\n        breaker_name=breaker.name\n    )\n\n# Registrar listeners\nfor breaker in [\n    inventory_circuit_breaker,\n    payment_gateway_circuit_breaker,\n    database_circuit_breaker\n]:\n    breaker.add_listener(on_circuit_open)\n    breaker.add_listener(on_circuit_close)\n    breaker.add_listener(on_circuit_half_open)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"uso-de-circuit-breaker",children:"Uso de Circuit Breaker"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# src/grpc/inventory_client.py\nfrom src.circuit_breaker import inventory_circuit_breaker\nfrom src.exceptions.infrastructure import CircuitBreakerOpenError\nfrom pybreaker import CircuitBreakerError\n\nclass InventoryGRPCClient:\n    """Cliente gRPC con circuit breaker."""\n\n    async def reserve_stock(\n        self,\n        organization_id: str,\n        order_id: str,\n        items: list\n    ):\n        """Reservar stock con circuit breaker."""\n\n        try:\n            # Envolver llamada con circuit breaker\n            return await inventory_circuit_breaker.call(\n                self._reserve_stock_internal,\n                organization_id,\n                order_id,\n                items\n            )\n\n        except CircuitBreakerError:\n            # Circuit abierto - usar fallback\n            logger.warning(\n                "inventory_circuit_open_using_fallback",\n                organization_id=organization_id,\n                order_id=order_id\n            )\n\n            raise CircuitBreakerOpenError("inventory-service")\n\n    async def _reserve_stock_internal(\n        self,\n        organization_id: str,\n        order_id: str,\n        items: list\n    ):\n        """Implementaci\xf3n real de reserva."""\n\n        async with grpc.aio.insecure_channel(\n            f"{self.host}:{self.port}"\n        ) as channel:\n            stub = inventory_pb2_grpc.InventoryServiceStub(channel)\n\n            request = inventory_pb2.ReserveStockRequest(\n                organization_id=organization_id,\n                order_id=order_id,\n                items=[\n                    inventory_pb2.ReserveItem(\n                        variant_id=item["variant_id"],\n                        quantity=item["quantity"]\n                    )\n                    for item in items\n                ]\n            )\n\n            response = await stub.ReserveStock(request, timeout=5.0)\n\n            return response\n\n# src/services/order_service.py\nfrom src.exceptions.infrastructure import CircuitBreakerOpenError\n\nclass OrderService:\n    """Servicio con manejo de circuit breaker."""\n\n    async def create_order(\n        self,\n        organization_id: str,\n        order_data: dict\n    ) -> Order:\n        """Crear orden con fallback si inventory no disponible."""\n\n        # Crear orden en BD\n        order = await self.repo.create(order_data)\n\n        try:\n            # Intentar reservar stock\n            reservation = await self.inventory_client.reserve_stock(\n                organization_id=organization_id,\n                order_id=order.order_id,\n                items=order_data["items"]\n            )\n\n            # Actualizar orden con reservation_id\n            order.reservation_id = reservation.reservation_id\n            await self.repo.update(order)\n\n        except CircuitBreakerOpenError:\n            # Inventory no disponible - marcar orden como "pending_stock"\n            logger.warning(\n                "order_created_without_reservation",\n                order_id=order.order_id,\n                reason="inventory_circuit_open"\n            )\n\n            order.status = "pending_stock"\n            order.notes = "Stock reservation pending - inventory service unavailable"\n            await self.repo.update(order)\n\n            # Publicar evento para retry as\xedncrono\n            await self.event_publisher.publish(\n                OrderCreatedWithoutReservationEvent(\n                    order_id=order.order_id,\n                    organization_id=organization_id,\n                    items=order_data["items"]\n                )\n            )\n\n        return order\n'})}),"\n",(0,i.jsx)(n.h2,{id:"5-timeouts",children:"5. Timeouts"}),"\n",(0,i.jsx)(n.h3,{id:"configuraci\xf3n-de-timeouts",children:"Configuraci\xf3n de Timeouts"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# src/config.py\nfrom pydantic_settings import BaseSettings\n\nclass Settings(BaseSettings):\n    """Configuraci\xf3n con timeouts."""\n\n    # HTTP client timeouts\n    HTTP_CONNECT_TIMEOUT: float = 5.0\n    HTTP_READ_TIMEOUT: float = 30.0\n    HTTP_TOTAL_TIMEOUT: float = 60.0\n\n    # gRPC timeouts\n    GRPC_CALL_TIMEOUT: float = 10.0\n    GRPC_CONNECTION_TIMEOUT: float = 5.0\n\n    # Database timeouts\n    DB_CONNECTION_TIMEOUT: float = 10.0\n    DB_QUERY_TIMEOUT: float = 30.0\n\n    # Redis timeouts\n    REDIS_SOCKET_TIMEOUT: float = 5.0\n    REDIS_SOCKET_CONNECT_TIMEOUT: float = 3.0\n\n    # RabbitMQ timeouts\n    RABBITMQ_CONNECTION_TIMEOUT: float = 10.0\n    RABBITMQ_HEARTBEAT: int = 60\n\nsettings = Settings()\n'})}),"\n",(0,i.jsx)(n.h3,{id:"aplicar-timeouts",children:"Aplicar Timeouts"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# src/database.py\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom src.config import settings\n\nengine = create_async_engine(\n    settings.DATABASE_URL,\n    connect_args={\n        "timeout": settings.DB_CONNECTION_TIMEOUT,\n        "command_timeout": settings.DB_QUERY_TIMEOUT\n    },\n    pool_pre_ping=True,  # Verificar conexiones antes de usar\n    pool_recycle=3600    # Reciclar conexiones cada hora\n)\n\n# src/cache.py\nimport redis.asyncio as redis\n\nredis_client = redis.from_url(\n    settings.REDIS_URL,\n    socket_timeout=settings.REDIS_SOCKET_TIMEOUT,\n    socket_connect_timeout=settings.REDIS_SOCKET_CONNECT_TIMEOUT,\n    retry_on_timeout=True,\n    health_check_interval=30\n)\n\n# src/grpc/client.py\nimport grpc\n\nclass InventoryGRPCClient:\n    """Cliente gRPC con timeouts."""\n\n    async def reserve_stock(self, organization_id: str, order_id: str, items: list):\n        """Reservar con timeout."""\n\n        async with grpc.aio.insecure_channel(\n            f"{self.host}:{self.port}",\n            options=[\n                (\'grpc.keepalive_time_ms\', 10000),\n                (\'grpc.keepalive_timeout_ms\', 5000),\n                (\'grpc.http2.max_pings_without_data\', 0),\n            ]\n        ) as channel:\n            stub = inventory_pb2_grpc.InventoryServiceStub(channel)\n\n            # Timeout espec\xedfico para esta operaci\xf3n\n            response = await stub.ReserveStock(\n                request,\n                timeout=settings.GRPC_CALL_TIMEOUT\n            )\n\n            return response\n\n# src/http_client.py\nimport httpx\nfrom src.config import settings\n\nasync def create_http_client() -> httpx.AsyncClient:\n    """Crear cliente HTTP con timeouts."""\n\n    timeout = httpx.Timeout(\n        connect=settings.HTTP_CONNECT_TIMEOUT,\n        read=settings.HTTP_READ_TIMEOUT,\n        write=10.0,\n        pool=5.0\n    )\n\n    return httpx.AsyncClient(\n        timeout=timeout,\n        limits=httpx.Limits(\n            max_connections=100,\n            max_keepalive_connections=20\n        )\n    )\n'})}),"\n",(0,i.jsx)(n.h2,{id:"6-graceful-degradation",children:"6. Graceful Degradation"}),"\n",(0,i.jsx)(n.h3,{id:"fallback-strategies",children:"Fallback Strategies"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# src/services/catalog_service.py\nimport structlog\n\nlogger = structlog.get_logger(__name__)\n\nclass CatalogService:\n    """Servicio con graceful degradation."""\n\n    async def get_product_with_stock(\n        self,\n        product_id: str,\n        organization_id: str\n    ) -> dict:\n        """Obtener producto con informaci\xf3n de stock (best effort)."""\n\n        # 1. Obtener producto (critical)\n        product = await self.product_repo.get_by_id(\n            product_id,\n            organization_id\n        )\n\n        if not product:\n            raise NotFoundError("Product", product_id)\n\n        product_dict = product.to_dict()\n\n        # 2. Intentar obtener stock (optional - con fallback)\n        try:\n            stock_info = await self._get_stock_info(product_id)\n            product_dict["stock"] = stock_info\n\n        except CircuitBreakerOpenError:\n            logger.warning(\n                "stock_unavailable_circuit_open",\n                product_id=product_id\n            )\n            product_dict["stock"] = {\n                "available": None,\n                "status": "unavailable"\n            }\n\n        except Exception as e:\n            logger.error(\n                "stock_fetch_failed",\n                product_id=product_id,\n                error=str(e)\n            )\n            product_dict["stock"] = {\n                "available": None,\n                "status": "error"\n            }\n\n        # 3. Intentar obtener precios din\xe1micos (optional)\n        try:\n            pricing = await self._get_dynamic_pricing(product_id)\n            product_dict["pricing"] = pricing\n\n        except Exception as e:\n            logger.warning(\n                "dynamic_pricing_failed_using_base_price",\n                product_id=product_id,\n                error=str(e)\n            )\n            # Fallback a precio base\n            product_dict["pricing"] = {\n                "price": product.base_price,\n                "type": "base"\n            }\n\n        return product_dict\n\n    @inventory_circuit_breaker\n    async def _get_stock_info(self, product_id: str) -> dict:\n        """Obtener info de stock (con circuit breaker)."""\n        return await self.inventory_client.get_stock(product_id)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"cache-como-fallback",children:"Cache como Fallback"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# src/services/product_service.py\nclass ProductService:\n    """Servicio con cache como fallback."""\n\n    async def get_product(\n        self,\n        product_id: str,\n        organization_id: str\n    ) -> Product:\n        """Obtener producto con cache fallback."""\n\n        # 1. Intentar cache primero\n        try:\n            cached = await self.cache.get_product(product_id)\n            if cached:\n                logger.info("product_served_from_cache", product_id=product_id)\n                return Product(**cached)\n\n        except Exception as e:\n            logger.warning(\n                "cache_read_failed",\n                product_id=product_id,\n                error=str(e)\n            )\n\n        # 2. Obtener de BD\n        try:\n            product = await self.repo.get_by_id(product_id, organization_id)\n\n            if not product:\n                raise NotFoundError("Product", product_id)\n\n            # 3. Actualizar cache (best effort)\n            try:\n                await self.cache.set_product(\n                    product_id,\n                    product.to_dict(),\n                    ttl=3600\n                )\n            except Exception as e:\n                logger.warning(\n                    "cache_write_failed",\n                    product_id=product_id,\n                    error=str(e)\n                )\n\n            return product\n\n        except OperationalError as e:\n            # BD no disponible - intentar servir desde cache stale\n            logger.error(\n                "database_unavailable_attempting_stale_cache",\n                product_id=product_id,\n                error=str(e)\n            )\n\n            try:\n                # Intentar cache sin TTL check\n                stale_cached = await self.cache.get_product(\n                    product_id,\n                    allow_stale=True\n                )\n\n                if stale_cached:\n                    logger.warning(\n                        "serving_stale_cache_data",\n                        product_id=product_id\n                    )\n                    return Product(**stale_cached)\n\n            except Exception:\n                pass\n\n            # Sin fallback disponible\n            raise DatabaseError("get_product", str(e))\n'})}),"\n",(0,i.jsx)(n.h2,{id:"7-dead-letter-queue",children:"7. Dead Letter Queue"}),"\n",(0,i.jsx)(n.h3,{id:"configuraci\xf3n-dlq",children:"Configuraci\xf3n DLQ"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# src/events/setup.py\nimport aio_pika\n\nasync def setup_event_queues(channel: aio_pika.Channel):\n    """Configurar queues con DLQ."""\n\n    # Dead Letter Exchange\n    dlx = await channel.declare_exchange(\n        "dlx.events",\n        aio_pika.ExchangeType.TOPIC,\n        durable=True\n    )\n\n    # Dead Letter Queue\n    dlq = await channel.declare_queue(\n        "dlq.events",\n        durable=True\n    )\n\n    await dlq.bind(dlx, routing_key="#")\n\n    # Main exchange\n    exchange = await channel.declare_exchange(\n        "order.events",\n        aio_pika.ExchangeType.TOPIC,\n        durable=True\n    )\n\n    # Queue con DLQ configurado\n    queue = await channel.declare_queue(\n        "order.created.inventory",\n        durable=True,\n        arguments={\n            # Enviar a DLX despu\xe9s de rechazar\n            "x-dead-letter-exchange": "dlx.events",\n            "x-dead-letter-routing-key": "order.created.failed",\n\n            # Max retries antes de DLQ\n            "x-max-delivery-count": 3,\n\n            # TTL para mensajes (opcional)\n            "x-message-ttl": 3600000  # 1 hora\n        }\n    )\n\n    await queue.bind(exchange, routing_key="order.created")\n\n    return queue\n'})}),"\n",(0,i.jsx)(n.h3,{id:"consumer-con-dlq",children:"Consumer con DLQ"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# src/events/consumer.py\nimport aio_pika\n\nclass EventConsumer:\n    """Consumer que env\xeda mensajes fallidos a DLQ."""\n\n    async def handle_message(\n        self,\n        message: aio_pika.IncomingMessage\n    ) -> None:\n        """Procesar mensaje con manejo de DLQ."""\n\n        try:\n            # Extraer datos\n            event_data = json.loads(message.body)\n\n            # Procesar\n            await self._process_event(event_data)\n\n            # ACK si exitoso\n            await message.ack()\n\n        except Exception as e:\n            logger.error(\n                "event_processing_failed",\n                event_id=event_data.get("event_id"),\n                error=str(e),\n                delivery_count=message.headers.get("x-delivery-count", 0),\n                exc_info=True\n            )\n\n            # NACK - ser\xe1 reencolado o enviado a DLQ\n            # seg\xfan x-max-delivery-count\n            await message.nack(requeue=True)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"pr\xf3ximos-pasos",children:"Pr\xf3ximos Pasos"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/resiliencia/circuit-breaker",children:"Circuit Breaker Patterns"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/resiliencia/chaos-engineering",children:"Chaos Engineering"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/resiliencia/disaster-recovery",children:"Disaster Recovery"})}),"\n"]})]})}function _(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>s});var t=r(6540);const i={},a=t.createContext(i);function o(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);