"use strict";(globalThis.webpackChunkerp_docs=globalThis.webpackChunkerp_docs||[]).push([[6434],{3968:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>c,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"microservicios/catalog-service/arquitectura","title":"Arquitectura Interna","description":"Capas de la Arquitectura","source":"@site/docs/02-microservicios/catalog-service/02-arquitectura.md","sourceDirName":"02-microservicios/catalog-service","slug":"/microservicios/catalog-service/arquitectura","permalink":"/zenlogic/microservicios/catalog-service/arquitectura","draft":false,"unlisted":false,"editUrl":"https://github.com/your-repo/edit/main/docs/02-microservicios/catalog-service/02-arquitectura.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"docs","previous":{"title":"Alcance del Catalog Service","permalink":"/zenlogic/microservicios/catalog-service/alcance"},"next":{"title":"Modelo de Datos","permalink":"/zenlogic/microservicios/catalog-service/modelo-datos"}}');var r=a(4848),i=a(8453);const c={sidebar_position:3},o="Arquitectura Interna",s={},l=[{value:"Capas de la Arquitectura",id:"capas-de-la-arquitectura",level:2},{value:"Estructura de Directorios",id:"estructura-de-directorios",level:2},{value:"Service Layer",id:"service-layer",level:2},{value:"Product Service",id:"product-service",level:3},{value:"Auth gRPC Client",id:"auth-grpc-client",level:2},{value:"Event Consumer",id:"event-consumer",level:2},{value:"Middleware de Validaci\xf3n de Local",id:"middleware-de-validaci\xf3n-de-local",level:2},{value:"Pr\xf3ximos Pasos",id:"pr\xf3ximos-pasos",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"arquitectura-interna",children:"Arquitectura Interna"})}),"\n",(0,r.jsx)(n.h2,{id:"capas-de-la-arquitectura",children:"Capas de la Arquitectura"}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n    subgraph "External"\n        Client[Clients]\n        AuthService[Auth Service]\n    end\n\n    subgraph "Catalog Service"\n        direction TB\n\n        subgraph "API Layer"\n            REST[REST API<br/>FastAPI]\n        end\n\n        subgraph "Service Layer"\n            ProductSvc[Product Service]\n            VariantSvc[Variant Service]\n            OptionSvc[Option Service]\n        end\n\n        subgraph "Repository Layer"\n            ProductRepo[Product Repository]\n            VariantRepo[Variant Repository]\n            OptionRepo[Option Repository]\n        end\n\n        subgraph "Clients"\n            AuthClient[Auth gRPC Client]\n        end\n\n        subgraph "Infrastructure"\n            EventPub[Event Publisher]\n            EventCons[Event Consumer]\n            Cache[Cache Manager]\n        end\n    end\n\n    subgraph "Data Layer"\n        PG[(PostgreSQL)]\n        Redis[(Redis)]\n        RMQ[RabbitMQ]\n    end\n\n    Client --\x3e|HTTP| REST\n    REST --\x3e ProductSvc\n    REST --\x3e VariantSvc\n\n    ProductSvc --\x3e ProductRepo\n    VariantSvc --\x3e VariantRepo\n    ProductSvc --\x3e AuthClient\n\n    ProductRepo --\x3e PG\n    VariantRepo --\x3e PG\n\n    ProductSvc --\x3e Cache\n    Cache --\x3e Redis\n\n    ProductSvc --\x3e EventPub\n    EventPub --\x3e RMQ\n\n    EventCons --\x3e RMQ\n    EventCons --\x3e Cache\n\n    AuthClient --\x3e|gRPC| AuthService'}),"\n",(0,r.jsx)(n.h2,{id:"estructura-de-directorios",children:"Estructura de Directorios"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"catalog-service/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u2514\u2500\u2500 rest/\n\u2502   \u2502       \u251c\u2500\u2500 products.py\n\u2502   \u2502       \u251c\u2500\u2500 variants.py\n\u2502   \u2502       \u2514\u2500\u2500 options.py\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u251c\u2500\u2500 product_service.py\n\u2502   \u2502   \u251c\u2500\u2500 variant_service.py\n\u2502   \u2502   \u2514\u2500\u2500 option_service.py\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 repositories/\n\u2502   \u2502   \u251c\u2500\u2500 product_repository.py\n\u2502   \u2502   \u251c\u2500\u2500 variant_repository.py\n\u2502   \u2502   \u2514\u2500\u2500 option_repository.py\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 models/\n\u2502   \u2502   \u251c\u2500\u2500 product.py\n\u2502   \u2502   \u251c\u2500\u2500 product_variant.py\n\u2502   \u2502   \u251c\u2500\u2500 option.py\n\u2502   \u2502   \u2514\u2500\u2500 option_value.py\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 schemas/\n\u2502   \u2502   \u251c\u2500\u2500 product.py\n\u2502   \u2502   \u251c\u2500\u2500 variant.py\n\u2502   \u2502   \u2514\u2500\u2500 option.py\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 clients/\n\u2502   \u2502   \u2514\u2500\u2500 auth_client.py\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 infrastructure/\n\u2502   \u2502   \u251c\u2500\u2500 event_publisher.py\n\u2502   \u2502   \u251c\u2500\u2500 event_consumer.py\n\u2502   \u2502   \u2514\u2500\u2500 cache.py\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 middleware/\n\u2502   \u2502   \u2514\u2500\u2500 local_validation.py\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 main.py\n\u2502\n\u251c\u2500\u2500 tests/\n\u251c\u2500\u2500 migrations/\n\u251c\u2500\u2500 Dockerfile\n\u2514\u2500\u2500 requirements.txt\n"})}),"\n",(0,r.jsx)(n.h2,{id:"service-layer",children:"Service Layer"}),"\n",(0,r.jsx)(n.h3,{id:"product-service",children:"Product Service"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class ProductService:\n    def __init__(\n        self,\n        product_repo: ProductRepository,\n        variant_repo: VariantRepository,\n        auth_client: AuthClient,\n        event_publisher: EventPublisher,\n        cache: CacheManager\n    ):\n        self.product_repo = product_repo\n        self.variant_repo = variant_repo\n        self.auth_client = auth_client\n        self.event_publisher = event_publisher\n        self.cache = cache\n\n    async def create_product(\n        self,\n        data: ProductCreate,\n        user: User\n    ) -> Product:\n        """Crear producto con variantes"""\n\n        # 1. Validar locales de las variantes\n        for variant_data in data.variants:\n            await self._validate_local(\n                variant_data.warehouseId,\n                user.organization_id\n            )\n\n        # 2. Validar SKUs \xfanicos\n        for variant_data in data.variants:\n            exists = await self.variant_repo.exists_sku(\n                variant_data.sku,\n                user.organization_id\n            )\n            if exists:\n                raise ValidationError(f"SKU {variant_data.sku} ya existe")\n\n        # 3. Crear producto y variantes en transacci\xf3n\n        async with UnitOfWork(db) as uow:\n            product = Product(**data.dict(), organization_id=user.organization_id)\n            product = await self.product_repo.create(product)\n\n            for variant_data in data.variants:\n                variant = ProductVariant(\n                    **variant_data.dict(),\n                    product_id=product.id\n                )\n                await self.variant_repo.create(variant)\n\n        # 4. Publicar evento\n        await self.event_publisher.publish(\n            "catalog.product.created",\n            {\n                "product_id": product.id,\n                "organization_id": user.organization_id,\n                "variants_count": len(data.variants)\n            }\n        )\n\n        return product\n\n    async def _validate_local(self, local_id: str, org_id: str):\n        """Validar que local existe en Auth Service"""\n        # Intentar obtener de cache\n        cache_key = f"local:{org_id}:{local_id}"\n        cached = await self.cache.get(cache_key)\n\n        if cached:\n            return True\n\n        # Consultar a Auth Service v\xeda gRPC\n        try:\n            local = await self.auth_client.get_local(local_id, org_id)\n\n            # Cachear por 10 minutos\n            await self.cache.set(cache_key, local, ttl=600)\n\n            return True\n        except NotFoundError:\n            raise ValidationError(f"Local {local_id} no existe")\n'})}),"\n",(0,r.jsx)(n.h2,{id:"auth-grpc-client",children:"Auth gRPC Client"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import grpc\nimport auth_pb2\nimport auth_pb2_grpc\n\nclass AuthClient:\n    def __init__(self, grpc_url: str):\n        self.channel = grpc.aio.insecure_channel(grpc_url)\n        self.stub = auth_pb2_grpc.AuthServiceStub(self.channel)\n\n    async def verify_token(self, token: str):\n        """Verificar token y obtener usuario"""\n        request = auth_pb2.VerifyTokenRequest(token=token)\n\n        try:\n            response = await self.stub.VerifyToken(request, timeout=5.0)\n            return {\n                "user_id": response.user_id,\n                "organization_id": response.organization_id,\n                "permissions": list(response.permissions),\n                "locals": list(response.locals)\n            }\n        except grpc.RpcError as e:\n            if e.code() == grpc.StatusCode.UNAUTHENTICATED:\n                raise UnauthorizedError("Token inv\xe1lido")\n            raise\n\n    async def get_local(self, local_id: str, org_id: str):\n        """Obtener informaci\xf3n de local"""\n        # Implementaci\xf3n similar\n        pass\n'})}),"\n",(0,r.jsx)(n.h2,{id:"event-consumer",children:"Event Consumer"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import pika\nimport json\n\nclass EventConsumer:\n    def __init__(self, cache: CacheManager):\n        self.cache = cache\n        self.connection = pika.BlockingConnection(\n            pika.ConnectionParameters(\'localhost\')\n        )\n        self.channel = self.connection.channel()\n\n    def start(self):\n        """Iniciar consumo de eventos"""\n\n        # Declarar exchange\n        self.channel.exchange_declare(\n            exchange=\'auth_events\',\n            exchange_type=\'topic\',\n            durable=True\n        )\n\n        # Crear queue\n        self.channel.queue_declare(\n            queue=\'catalog_auth_events\',\n            durable=True\n        )\n\n        # Bind a eventos espec\xedficos\n        self.channel.queue_bind(\n            exchange=\'auth_events\',\n            queue=\'catalog_auth_events\',\n            routing_key=\'auth.user.*\'\n        )\n        self.channel.queue_bind(\n            exchange=\'auth_events\',\n            queue=\'catalog_auth_events\',\n            routing_key=\'auth.local.*\'\n        )\n\n        # Consumir\n        self.channel.basic_consume(\n            queue=\'catalog_auth_events\',\n            on_message_callback=self.handle_event\n        )\n\n        self.channel.start_consuming()\n\n    def handle_event(self, ch, method, properties, body):\n        """Manejar evento recibido"""\n        event = json.loads(body)\n        event_type = event["event_type"]\n\n        if event_type == "auth.user.deactivated":\n            self._handle_user_deactivated(event)\n        elif event_type == "auth.local.deleted":\n            self._handle_local_deleted(event)\n        elif event_type == "auth.organization.suspended":\n            self._handle_org_suspended(event)\n\n        ch.basic_ack(delivery_tag=method.delivery_tag)\n\n    async def _handle_user_deactivated(self, event):\n        """Invalidar cache cuando usuario es desactivado"""\n        user_id = event["payload"]["user_id"]\n        await self.cache.delete(f"user:{user_id}")\n\n    async def _handle_local_deleted(self, event):\n        """Invalidar cache cuando local es eliminado"""\n        local_id = event["payload"]["local_id"]\n        org_id = event["payload"]["organization_id"]\n        await self.cache.delete(f"local:{org_id}:{local_id}")\n'})}),"\n",(0,r.jsx)(n.h2,{id:"middleware-de-validaci\xf3n-de-local",children:"Middleware de Validaci\xf3n de Local"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from fastapi import Request, HTTPException\n\nasync def validate_local_middleware(request: Request, call_next):\n    """\n    Middleware para validar locales en requests que los requieren\n    """\n\n    # Solo aplicar en endpoints que requieren local\n    if request.url.path.startswith("/api/v1/variants"):\n\n        # Obtener local_id del body o query\n        if request.method == "POST":\n            body = await request.json()\n            local_id = body.get("warehouseId")\n\n            if local_id:\n                user = request.state.user\n                auth_client = request.app.state.auth_client\n\n                # Validar que local existe\n                try:\n                    await auth_client.get_local(local_id, user.organization_id)\n                except NotFoundError:\n                    raise HTTPException(404, f"Local {local_id} no existe")\n\n                # Validar que usuario tiene acceso\n                if local_id not in user.locals and "local:access_all" not in user.permissions:\n                    raise HTTPException(403, f"Sin acceso al local {local_id}")\n\n    response = await call_next(request)\n    return response\n'})}),"\n",(0,r.jsx)(n.h2,{id:"pr\xf3ximos-pasos",children:"Pr\xf3ximos Pasos"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/microservicios/catalog-service/modelo-datos",children:"Modelo de Datos"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/microservicios/catalog-service/validacion-locales",children:"Validaci\xf3n de Locales"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/microservicios/catalog-service/auth-client-grpc",children:"Auth gRPC Client"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>c,x:()=>o});var t=a(6540);const r={},i=t.createContext(r);function c(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);