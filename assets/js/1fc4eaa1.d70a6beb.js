"use strict";(globalThis.webpackChunkerp_docs=globalThis.webpackChunkerp_docs||[]).push([[8787],{5778:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"testing/estrategia-testing","title":"Estrategia de Testing","description":"Estrategia completa de testing para la arquitectura de microservicios del ERP.","source":"@site/docs/05-testing/01-estrategia-testing.md","sourceDirName":"05-testing","slug":"/testing/estrategia-testing","permalink":"/zenlogic/testing/estrategia-testing","draft":false,"unlisted":false,"editUrl":"https://github.com/your-repo/edit/main/docs/05-testing/01-estrategia-testing.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1}}');var r=t(4848),i=t(8453);const a={sidebar_position:1},o="Estrategia de Testing",c={},d=[{value:"Pir\xe1mide de Testing",id:"pir\xe1mide-de-testing",level:2},{value:"Niveles de Testing",id:"niveles-de-testing",level:2},{value:"1. Unit Tests (60-70%)",id:"1-unit-tests-60-70",level:3},{value:"Herramientas",id:"herramientas",level:4},{value:"Qu\xe9 Testear",id:"qu\xe9-testear",level:4},{value:"Configuraci\xf3n pytest",id:"configuraci\xf3n-pytest",level:4},{value:"2. Integration Tests (20-30%)",id:"2-integration-tests-20-30",level:3},{value:"Herramientas",id:"herramientas-1",level:4},{value:"Setup con Testcontainers",id:"setup-con-testcontainers",level:4},{value:"Test de Repository con BD Real",id:"test-de-repository-con-bd-real",level:4},{value:"Test de Cache con Redis Real",id:"test-de-cache-con-redis-real",level:4},{value:"Test de Event Publishing",id:"test-de-event-publishing",level:4},{value:"3. API Tests",id:"3-api-tests",level:3},{value:"4. End-to-End Tests (5-10%)",id:"4-end-to-end-tests-5-10",level:3},{value:"Herramientas",id:"herramientas-2",level:4},{value:"Setup E2E",id:"setup-e2e",level:4},{value:"Test E2E: Flujo de Venta Completo",id:"test-e2e-flujo-de-venta-completo",level:4},{value:"Test E2E: Flujo de Devoluci\xf3n",id:"test-e2e-flujo-de-devoluci\xf3n",level:4},{value:"Estrategia de Ejecuci\xf3n",id:"estrategia-de-ejecuci\xf3n",level:2},{value:"CI/CD Pipeline",id:"cicd-pipeline",level:3},{value:"Comandos Locales",id:"comandos-locales",level:3},{value:"M\xe9tricas de Calidad",id:"m\xe9tricas-de-calidad",level:2},{value:"Cobertura M\xednima",id:"cobertura-m\xednima",level:3},{value:"Performance Benchmarks",id:"performance-benchmarks",level:3},{value:"Pr\xf3ximos Pasos",id:"pr\xf3ximos-pasos",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"estrategia-de-testing",children:"Estrategia de Testing"})}),"\n",(0,r.jsx)(n.p,{children:"Estrategia completa de testing para la arquitectura de microservicios del ERP."}),"\n",(0,r.jsx)(n.h2,{id:"pir\xe1mide-de-testing",children:"Pir\xe1mide de Testing"}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n    subgraph "E2E Tests"\n        E2E[5-10% de tests<br/>Flujos completos]\n    end\n\n    subgraph "Integration Tests"\n        INT[20-30% de tests<br/>Servicios + BD + Queue]\n    end\n\n    subgraph "Unit Tests"\n        UNIT[60-70% de tests<br/>L\xf3gica de negocio aislada]\n    end\n\n    UNIT --\x3e INT\n    INT --\x3e E2E\n\n    style UNIT fill:#90EE90\n    style INT fill:#FFD700\n    style E2E fill:#FF6B6B'}),"\n",(0,r.jsx)(n.h2,{id:"niveles-de-testing",children:"Niveles de Testing"}),"\n",(0,r.jsx)(n.h3,{id:"1-unit-tests-60-70",children:"1. Unit Tests (60-70%)"}),"\n",(0,r.jsx)(n.p,{children:"Pruebas de componentes aislados: funciones, clases, m\xe9todos."}),"\n",(0,r.jsx)(n.h4,{id:"herramientas",children:"Herramientas"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Framework"}),": ",(0,r.jsx)(n.code,{children:"pytest"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mocking"}),": ",(0,r.jsx)(n.code,{children:"pytest-mock"}),", ",(0,r.jsx)(n.code,{children:"unittest.mock"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Coverage"}),": ",(0,r.jsx)(n.code,{children:"pytest-cov"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fixtures"}),": ",(0,r.jsx)(n.code,{children:"pytest"})," fixtures para setup/teardown"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"qu\xe9-testear",children:"Qu\xe9 Testear"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Repositories"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# tests/unit/test_product_repository.py\nimport pytest\nfrom unittest.mock import Mock, AsyncMock\nfrom repositories.product_repository import ProductRepository\nfrom models.product import Product\n\n@pytest.fixture\ndef mock_db():\n    """Mock de sesi\xf3n de base de datos."""\n    db = Mock()\n    db.execute = AsyncMock()\n    db.commit = AsyncMock()\n    db.rollback = AsyncMock()\n    return db\n\n@pytest.fixture\ndef product_repo(mock_db):\n    """Repository con DB mockeada."""\n    return ProductRepository(mock_db)\n\nclass TestProductRepository:\n    """Tests unitarios para ProductRepository."""\n\n    async def test_create_product_success(self, product_repo, mock_db):\n        """Debe crear producto correctamente."""\n        # Arrange\n        product_data = {\n            "name": "Test Product",\n            "sku": "TEST-001",\n            "organization_id": "org-123"\n        }\n\n        # Act\n        result = await product_repo.create(product_data)\n\n        # Assert\n        assert result is not None\n        mock_db.execute.assert_called_once()\n        mock_db.commit.assert_called_once()\n\n    async def test_create_product_duplicate_sku(self, product_repo, mock_db):\n        """Debe fallar al crear producto con SKU duplicado."""\n        from sqlalchemy.exc import IntegrityError\n\n        # Arrange\n        mock_db.commit.side_effect = IntegrityError(\n            "duplicate key", {}, None\n        )\n\n        # Act & Assert\n        with pytest.raises(IntegrityError):\n            await product_repo.create({"sku": "DUPLICATE"})\n\n        mock_db.rollback.assert_called_once()\n\n    async def test_get_by_id_not_found(self, product_repo, mock_db):\n        """Debe retornar None si producto no existe."""\n        # Arrange\n        mock_db.execute.return_value.scalar_one_or_none.return_value = None\n\n        # Act\n        result = await product_repo.get_by_id("nonexistent-id")\n\n        # Assert\n        assert result is None\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Services (Business Logic)"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# tests/unit/test_pricing_service.py\nimport pytest\nfrom services.pricing_service import PricingService\nfrom models.product import Product, PriceRule\n\n@pytest.fixture\ndef pricing_service():\n    return PricingService()\n\nclass TestPricingService:\n    """Tests de l\xf3gica de precios."""\n\n    def test_calculate_price_no_rules(self, pricing_service):\n        """Precio base sin reglas de descuento."""\n        product = Product(base_price=100.0)\n\n        price = pricing_service.calculate_price(\n            product=product,\n            quantity=1,\n            customer_tier=None\n        )\n\n        assert price == 100.0\n\n    def test_calculate_price_with_volume_discount(self, pricing_service):\n        """Descuento por volumen."""\n        product = Product(\n            base_price=100.0,\n            price_rules=[\n                PriceRule(\n                    rule_type="volume_discount",\n                    min_quantity=10,\n                    discount_percentage=15.0\n                )\n            ]\n        )\n\n        # Sin descuento (qty < 10)\n        price = pricing_service.calculate_price(product, quantity=5)\n        assert price == 100.0\n\n        # Con descuento (qty >= 10)\n        price = pricing_service.calculate_price(product, quantity=10)\n        assert price == 85.0  # 15% off\n\n    def test_calculate_price_with_tier_discount(self, pricing_service):\n        """Descuento por tier de cliente."""\n        product = Product(\n            base_price=100.0,\n            price_rules=[\n                PriceRule(\n                    rule_type="customer_tier",\n                    customer_tier="premium",\n                    discount_percentage=20.0\n                )\n            ]\n        )\n\n        # Cliente regular\n        price = pricing_service.calculate_price(\n            product, quantity=1, customer_tier="regular"\n        )\n        assert price == 100.0\n\n        # Cliente premium\n        price = pricing_service.calculate_price(\n            product, quantity=1, customer_tier="premium"\n        )\n        assert price == 80.0  # 20% off\n\n    def test_calculate_price_stacks_discounts(self, pricing_service):\n        """Descuentos se acumulan correctamente."""\n        product = Product(\n            base_price=100.0,\n            price_rules=[\n                PriceRule(\n                    rule_type="volume_discount",\n                    min_quantity=10,\n                    discount_percentage=10.0\n                ),\n                PriceRule(\n                    rule_type="customer_tier",\n                    customer_tier="premium",\n                    discount_percentage=15.0\n                )\n            ]\n        )\n\n        price = pricing_service.calculate_price(\n            product, quantity=10, customer_tier="premium"\n        )\n\n        # 10% volume + 15% tier = 23.5% total\n        # 100 - 10 = 90, 90 - 13.5 = 76.5\n        assert price == 76.5\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Validators"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# tests/unit/test_stock_validator.py\nimport pytest\nfrom validators.stock_validator import StockValidator\nfrom exceptions import InsufficientStockError\n\nclass TestStockValidator:\n    """Tests de validaci\xf3n de stock."""\n\n    def test_validate_availability_sufficient_stock(self):\n        """Stock disponible suficiente."""\n        validator = StockValidator()\n\n        # No debe lanzar excepci\xf3n\n        validator.validate_availability(\n            available_quantity=100,\n            requested_quantity=50\n        )\n\n    def test_validate_availability_insufficient_stock(self):\n        """Stock insuficiente debe fallar."""\n        validator = StockValidator()\n\n        with pytest.raises(InsufficientStockError) as exc_info:\n            validator.validate_availability(\n                available_quantity=10,\n                requested_quantity=50\n            )\n\n        assert "Insufficient stock" in str(exc_info.value)\n        assert exc_info.value.available == 10\n        assert exc_info.value.requested == 50\n\n    def test_validate_reservation_ttl_not_expired(self):\n        """Reserva no expirada."""\n        from datetime import datetime, timedelta\n\n        validator = StockValidator()\n\n        expires_at = datetime.utcnow() + timedelta(minutes=10)\n\n        # No debe lanzar excepci\xf3n\n        validator.validate_reservation_ttl(expires_at)\n\n    def test_validate_reservation_ttl_expired(self):\n        """Reserva expirada debe fallar."""\n        from datetime import datetime, timedelta\n        from exceptions import ReservationExpiredError\n\n        validator = StockValidator()\n\n        expires_at = datetime.utcnow() - timedelta(minutes=5)\n\n        with pytest.raises(ReservationExpiredError):\n            validator.validate_reservation_ttl(expires_at)\n'})}),"\n",(0,r.jsx)(n.h4,{id:"configuraci\xf3n-pytest",children:"Configuraci\xf3n pytest"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# pytest.ini\n[pytest]\ntestpaths = tests\npython_files = test_*.py\npython_classes = Test*\npython_functions = test_*\n\n# Async support\nasyncio_mode = auto\n\n# Coverage\naddopts =\n    --cov=src\n    --cov-report=html\n    --cov-report=term-missing\n    --cov-fail-under=80\n    -v\n    --tb=short\n\n# Markers\nmarkers =\n    unit: Unit tests\n    integration: Integration tests\n    e2e: End-to-end tests\n    slow: Slow running tests\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# conftest.py\nimport pytest\nfrom typing import AsyncGenerator\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\n@pytest.fixture(scope="session")\ndef event_loop():\n    """Create event loop for async tests."""\n    import asyncio\n    loop = asyncio.get_event_loop_policy().new_event_loop()\n    yield loop\n    loop.close()\n\n@pytest.fixture\nasync def db_session() -> AsyncGenerator[AsyncSession, None]:\n    """Mock database session for unit tests."""\n    from unittest.mock import AsyncMock\n\n    session = AsyncMock(spec=AsyncSession)\n    session.execute = AsyncMock()\n    session.commit = AsyncMock()\n    session.rollback = AsyncMock()\n    session.close = AsyncMock()\n\n    yield session\n\n    await session.close()\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-integration-tests-20-30",children:"2. Integration Tests (20-30%)"}),"\n",(0,r.jsx)(n.p,{children:"Pruebas de integraci\xf3n entre componentes: BD, Redis, RabbitMQ, APIs externas."}),"\n",(0,r.jsx)(n.h4,{id:"herramientas-1",children:"Herramientas"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Framework"}),": ",(0,r.jsx)(n.code,{children:"pytest"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test Containers"}),": ",(0,r.jsx)(n.code,{children:"testcontainers-python"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"HTTP Client"}),": ",(0,r.jsx)(n.code,{children:"httpx"})," (async)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Database"}),": PostgreSQL real (via testcontainers)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Redis"}),": Redis real (via testcontainers)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"RabbitMQ"}),": RabbitMQ real (via testcontainers)"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"setup-con-testcontainers",children:"Setup con Testcontainers"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# tests/integration/conftest.py\nimport pytest\nfrom testcontainers.postgres import PostgresContainer\nfrom testcontainers.redis import RedisContainer\nfrom testcontainers.rabbitmq import RabbitMqContainer\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession\nfrom sqlalchemy.orm import sessionmaker\n\n@pytest.fixture(scope="session")\ndef postgres_container():\n    """PostgreSQL container para tests."""\n    with PostgresContainer("postgres:15-alpine") as postgres:\n        yield postgres\n\n@pytest.fixture(scope="session")\ndef redis_container():\n    """Redis container para tests."""\n    with RedisContainer("redis:7-alpine") as redis:\n        yield redis\n\n@pytest.fixture(scope="session")\ndef rabbitmq_container():\n    """RabbitMQ container para tests."""\n    with RabbitMqContainer("rabbitmq:3-management-alpine") as rabbitmq:\n        yield rabbitmq\n\n@pytest.fixture(scope="session")\nasync def engine(postgres_container):\n    """Database engine conectado a testcontainer."""\n    connection_url = postgres_container.get_connection_url().replace(\n        "psycopg2", "asyncpg"\n    )\n\n    engine = create_async_engine(connection_url, echo=True)\n\n    # Crear tablas\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n\n    yield engine\n\n    await engine.dispose()\n\n@pytest.fixture\nasync def db_session(engine):\n    """Session de base de datos para cada test."""\n    async_session = sessionmaker(\n        engine, class_=AsyncSession, expire_on_commit=False\n    )\n\n    async with async_session() as session:\n        yield session\n        await session.rollback()\n\n@pytest.fixture\nasync def redis_client(redis_container):\n    """Redis client conectado a testcontainer."""\n    import redis.asyncio as redis\n\n    client = redis.from_url(\n        f"redis://{redis_container.get_container_host_ip()}:"\n        f"{redis_container.get_exposed_port(6379)}"\n    )\n\n    yield client\n\n    await client.flushdb()\n    await client.close()\n\n@pytest.fixture\nasync def rabbitmq_channel(rabbitmq_container):\n    """RabbitMQ channel conectado a testcontainer."""\n    import aio_pika\n\n    connection = await aio_pika.connect_robust(\n        f"amqp://guest:guest@{rabbitmq_container.get_container_host_ip()}:"\n        f"{rabbitmq_container.get_exposed_port(5672)}/"\n    )\n\n    channel = await connection.channel()\n\n    yield channel\n\n    await channel.close()\n    await connection.close()\n'})}),"\n",(0,r.jsx)(n.h4,{id:"test-de-repository-con-bd-real",children:"Test de Repository con BD Real"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# tests/integration/test_product_repository_integration.py\nimport pytest\nfrom repositories.product_repository import ProductRepository\nfrom models.product import Product\nfrom sqlalchemy.exc import IntegrityError\n\n@pytest.mark.integration\nclass TestProductRepositoryIntegration:\n    """Integration tests para ProductRepository con BD real."""\n\n    async def test_create_and_retrieve_product(self, db_session):\n        """Debe crear y recuperar producto de BD."""\n        repo = ProductRepository(db_session)\n\n        # Create\n        product = await repo.create({\n            "name": "Integration Test Product",\n            "sku": "INT-001",\n            "organization_id": "org-test",\n            "base_price": 99.99,\n            "status": "active"\n        })\n\n        assert product.product_id is not None\n        assert product.name == "Integration Test Product"\n\n        # Retrieve\n        retrieved = await repo.get_by_id(product.product_id)\n\n        assert retrieved is not None\n        assert retrieved.product_id == product.product_id\n        assert retrieved.sku == "INT-001"\n\n    async def test_duplicate_sku_raises_error(self, db_session):\n        """Debe fallar al crear producto con SKU duplicado."""\n        repo = ProductRepository(db_session)\n\n        # First product\n        await repo.create({\n            "sku": "DUPLICATE-SKU",\n            "name": "Product 1",\n            "organization_id": "org-test"\n        })\n\n        # Duplicate SKU should fail\n        with pytest.raises(IntegrityError):\n            await repo.create({\n                "sku": "DUPLICATE-SKU",\n                "name": "Product 2",\n                "organization_id": "org-test"\n            })\n\n    async def test_update_product(self, db_session):\n        """Debe actualizar producto correctamente."""\n        repo = ProductRepository(db_session)\n\n        # Create\n        product = await repo.create({\n            "name": "Original Name",\n            "sku": "UPDATE-001",\n            "organization_id": "org-test",\n            "base_price": 50.0\n        })\n\n        # Update\n        updated = await repo.update(\n            product.product_id,\n            {"name": "Updated Name", "base_price": 75.0}\n        )\n\n        assert updated.name == "Updated Name"\n        assert updated.base_price == 75.0\n        assert updated.sku == "UPDATE-001"  # Unchanged\n\n    async def test_soft_delete(self, db_session):\n        """Debe soft-delete producto."""\n        repo = ProductRepository(db_session)\n\n        # Create\n        product = await repo.create({\n            "name": "To Delete",\n            "sku": "DELETE-001",\n            "organization_id": "org-test"\n        })\n\n        # Soft delete\n        await repo.soft_delete(product.product_id)\n\n        # Should not appear in normal queries\n        retrieved = await repo.get_by_id(product.product_id)\n        assert retrieved is None\n\n        # Should appear in query with deleted\n        deleted = await repo.get_by_id(\n            product.product_id,\n            include_deleted=True\n        )\n        assert deleted is not None\n        assert deleted.deleted_at is not None\n'})}),"\n",(0,r.jsx)(n.h4,{id:"test-de-cache-con-redis-real",children:"Test de Cache con Redis Real"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# tests/integration/test_product_cache_integration.py\nimport pytest\nfrom services.product_cache import ProductCache\nimport json\n\n@pytest.mark.integration\nclass TestProductCacheIntegration:\n    """Integration tests para cache con Redis real."""\n\n    async def test_cache_set_and_get(self, redis_client):\n        """Debe guardar y recuperar producto del cache."""\n        cache = ProductCache(redis_client)\n\n        product_data = {\n            "product_id": "prod-123",\n            "name": "Cached Product",\n            "base_price": 100.0\n        }\n\n        # Set cache\n        await cache.set_product("prod-123", product_data, ttl=300)\n\n        # Get cache\n        cached = await cache.get_product("prod-123")\n\n        assert cached is not None\n        assert cached["product_id"] == "prod-123"\n        assert cached["name"] == "Cached Product"\n\n    async def test_cache_expiration(self, redis_client):\n        """Debe expirar cache despu\xe9s de TTL."""\n        import asyncio\n        cache = ProductCache(redis_client)\n\n        # Set con TTL corto\n        await cache.set_product(\n            "prod-ttl",\n            {"product_id": "prod-ttl"},\n            ttl=1  # 1 segundo\n        )\n\n        # Debe existir inmediatamente\n        cached = await cache.get_product("prod-ttl")\n        assert cached is not None\n\n        # Esperar expiraci\xf3n\n        await asyncio.sleep(2)\n\n        # Debe haber expirado\n        cached = await cache.get_product("prod-ttl")\n        assert cached is None\n\n    async def test_cache_invalidation(self, redis_client):\n        """Debe invalidar cache correctamente."""\n        cache = ProductCache(redis_client)\n\n        await cache.set_product("prod-inv", {"data": "test"})\n\n        # Verificar existe\n        assert await cache.get_product("prod-inv") is not None\n\n        # Invalidar\n        await cache.invalidate_product("prod-inv")\n\n        # Debe estar vac\xedo\n        assert await cache.get_product("prod-inv") is None\n\n    async def test_cache_pattern_invalidation(self, redis_client):\n        """Debe invalidar m\xfaltiples keys por patr\xf3n."""\n        cache = ProductCache(redis_client)\n\n        # Crear m\xfaltiples entries\n        await cache.set_product("org:123:prod:1", {"id": "1"})\n        await cache.set_product("org:123:prod:2", {"id": "2"})\n        await cache.set_product("org:456:prod:3", {"id": "3"})\n\n        # Invalidar organizaci\xf3n 123\n        await cache.invalidate_pattern("org:123:*")\n\n        # org:123 debe estar vac\xedo\n        assert await cache.get_product("org:123:prod:1") is None\n        assert await cache.get_product("org:123:prod:2") is None\n\n        # org:456 debe existir\n        assert await cache.get_product("org:456:prod:3") is not None\n'})}),"\n",(0,r.jsx)(n.h4,{id:"test-de-event-publishing",children:"Test de Event Publishing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# tests/integration/test_event_publisher_integration.py\nimport pytest\nfrom events.publisher import EventPublisher\nfrom events.schemas import ProductCreatedEvent\nimport asyncio\nimport json\n\n@pytest.mark.integration\nclass TestEventPublisherIntegration:\n    """Integration tests para RabbitMQ event publishing."""\n\n    async def test_publish_and_consume_event(\n        self, rabbitmq_channel\n    ):\n        """Debe publicar evento y ser consumido."""\n        import aio_pika\n\n        # Setup exchange y queue\n        exchange = await rabbitmq_channel.declare_exchange(\n            "catalog.events",\n            aio_pika.ExchangeType.TOPIC,\n            durable=True\n        )\n\n        queue = await rabbitmq_channel.declare_queue(\n            "test_queue",\n            durable=True\n        )\n\n        await queue.bind(exchange, routing_key="product.created")\n\n        # Publisher\n        publisher = EventPublisher(rabbitmq_channel)\n\n        # Event to publish\n        event = ProductCreatedEvent(\n            event_id="evt-123",\n            product_id="prod-123",\n            name="Test Product",\n            sku="TEST-001",\n            organization_id="org-test"\n        )\n\n        # Publish\n        await publisher.publish(\n            exchange="catalog.events",\n            routing_key="product.created",\n            event=event\n        )\n\n        # Consume\n        consumed = []\n\n        async def on_message(message: aio_pika.IncomingMessage):\n            async with message.process():\n                consumed.append(json.loads(message.body))\n\n        await queue.consume(on_message)\n\n        # Esperar consumo\n        await asyncio.sleep(1)\n\n        # Verificar\n        assert len(consumed) == 1\n        assert consumed[0]["event_id"] == "evt-123"\n        assert consumed[0]["product_id"] == "prod-123"\n\n    async def test_event_idempotency(self, rabbitmq_channel, db_session):\n        """Eventos duplicados no deben procesarse dos veces."""\n        # Este test requiere event consumer que guarda event_id\n        # en audit_logs para prevenir duplicados\n        pass  # TODO: implementar con audit service\n'})}),"\n",(0,r.jsx)(n.h3,{id:"3-api-tests",children:"3. API Tests"}),"\n",(0,r.jsx)(n.p,{children:"Pruebas de endpoints HTTP completos."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# tests/integration/test_product_api.py\nimport pytest\nfrom httpx import AsyncClient\nfrom main import app\n\n@pytest.mark.integration\nclass TestProductAPI:\n    """Integration tests para Product API."""\n\n    async def test_create_product_success(self, db_session):\n        """POST /products debe crear producto."""\n        async with AsyncClient(app=app, base_url="http://test") as client:\n            response = await client.post(\n                "/api/v1/products",\n                json={\n                    "name": "API Test Product",\n                    "sku": "API-001",\n                    "base_price": 99.99,\n                    "category_id": "cat-123"\n                },\n                headers={"X-Organization-ID": "org-test"}\n            )\n\n        assert response.status_code == 201\n        data = response.json()\n        assert data["name"] == "API Test Product"\n        assert data["sku"] == "API-001"\n        assert "product_id" in data\n\n    async def test_create_product_validation_error(self):\n        """POST /products con datos inv\xe1lidos debe retornar 422."""\n        async with AsyncClient(app=app, base_url="http://test") as client:\n            response = await client.post(\n                "/api/v1/products",\n                json={\n                    "name": "",  # Nombre vac\xedo\n                    "base_price": -10  # Precio negativo\n                },\n                headers={"X-Organization-ID": "org-test"}\n            )\n\n        assert response.status_code == 422\n        assert "detail" in response.json()\n\n    async def test_get_product_success(self, db_session):\n        """GET /products/{id} debe retornar producto."""\n        # Crear producto primero\n        async with AsyncClient(app=app, base_url="http://test") as client:\n            create_response = await client.post(\n                "/api/v1/products",\n                json={\n                    "name": "Get Test",\n                    "sku": "GET-001",\n                    "base_price": 50.0\n                },\n                headers={"X-Organization-ID": "org-test"}\n            )\n\n            product_id = create_response.json()["product_id"]\n\n            # Get producto\n            get_response = await client.get(\n                f"/api/v1/products/{product_id}",\n                headers={"X-Organization-ID": "org-test"}\n            )\n\n        assert get_response.status_code == 200\n        data = get_response.json()\n        assert data["product_id"] == product_id\n        assert data["name"] == "Get Test"\n\n    async def test_get_product_not_found(self):\n        """GET /products/{id} con ID inexistente debe retornar 404."""\n        async with AsyncClient(app=app, base_url="http://test") as client:\n            response = await client.get(\n                "/api/v1/products/nonexistent-id",\n                headers={"X-Organization-ID": "org-test"}\n            )\n\n        assert response.status_code == 404\n\n    async def test_list_products_pagination(self, db_session):\n        """GET /products debe retornar lista paginada."""\n        # Crear m\xfaltiples productos\n        async with AsyncClient(app=app, base_url="http://test") as client:\n            for i in range(15):\n                await client.post(\n                    "/api/v1/products",\n                    json={\n                        "name": f"Product {i}",\n                        "sku": f"LIST-{i:03d}",\n                        "base_price": 10.0\n                    },\n                    headers={"X-Organization-ID": "org-test"}\n                )\n\n            # Get p\xe1gina 1\n            response = await client.get(\n                "/api/v1/products?page=1&page_size=10",\n                headers={"X-Organization-ID": "org-test"}\n            )\n\n        assert response.status_code == 200\n        data = response.json()\n        assert len(data["items"]) == 10\n        assert data["total"] >= 15\n        assert data["page"] == 1\n        assert data["page_size"] == 10\n'})}),"\n",(0,r.jsx)(n.h3,{id:"4-end-to-end-tests-5-10",children:"4. End-to-End Tests (5-10%)"}),"\n",(0,r.jsx)(n.p,{children:"Pruebas de flujos completos que involucran m\xfaltiples servicios."}),"\n",(0,r.jsx)(n.h4,{id:"herramientas-2",children:"Herramientas"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Orchestration"}),": Docker Compose con servicios reales"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"API Client"}),": ",(0,r.jsx)(n.code,{children:"httpx"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Assertions"}),": ",(0,r.jsx)(n.code,{children:"pytest"})]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"setup-e2e",children:"Setup E2E"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'# docker-compose.test.yml\nversion: \'3.8\'\n\nservices:\n  postgres-test:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_PASSWORD: test_password\n    ports:\n      - "5433:5432"\n\n  redis-test:\n    image: redis:7-alpine\n    ports:\n      - "6380:6379"\n\n  rabbitmq-test:\n    image: rabbitmq:3-management-alpine\n    ports:\n      - "5673:5672"\n      - "15673:15672"\n\n  catalog-service-test:\n    build: ./services/catalog-service\n    environment:\n      DATABASE_URL: postgresql://postgres:test_password@postgres-test:5432/catalog_db\n      REDIS_URL: redis://redis-test:6379/1\n      RABBITMQ_URL: amqp://guest:guest@rabbitmq-test:5672/\n    depends_on:\n      - postgres-test\n      - redis-test\n      - rabbitmq-test\n    ports:\n      - "8002:8002"\n\n  inventory-service-test:\n    build: ./services/inventory-service\n    environment:\n      DATABASE_URL: postgresql://postgres:test_password@postgres-test:5432/inventory_db\n      CATALOG_GRPC_HOST: catalog-service-test\n      CATALOG_GRPC_PORT: 50052\n    depends_on:\n      - postgres-test\n      - catalog-service-test\n    ports:\n      - "8003:8003"\n\n  order-service-test:\n    build: ./services/order-service\n    environment:\n      DATABASE_URL: postgresql://postgres:test_password@postgres-test:5432/order_db\n      INVENTORY_GRPC_HOST: inventory-service-test\n      INVENTORY_GRPC_PORT: 50053\n    depends_on:\n      - postgres-test\n      - inventory-service-test\n    ports:\n      - "8004:8004"\n'})}),"\n",(0,r.jsx)(n.h4,{id:"test-e2e-flujo-de-venta-completo",children:"Test E2E: Flujo de Venta Completo"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# tests/e2e/test_complete_sale_flow.py\nimport pytest\nfrom httpx import AsyncClient\nimport asyncio\n\n@pytest.mark.e2e\n@pytest.mark.slow\nclass TestCompleteSaleFlow:\n    """E2E test del flujo completo de venta."""\n\n    async def test_complete_order_workflow(self):\n        """\n        Test flujo completo:\n        1. Crear producto en Catalog\n        2. Crear stock en Inventory\n        3. Crear orden en Order Service\n        4. Reservar stock\n        5. Confirmar pago\n        6. Despachar orden\n        7. Deducir stock\n        """\n        catalog_url = "http://localhost:8002"\n        inventory_url = "http://localhost:8003"\n        order_url = "http://localhost:8004"\n\n        org_id = "e2e-org-123"\n\n        # 1. Crear producto\n        async with AsyncClient(base_url=catalog_url) as client:\n            product_response = await client.post(\n                "/api/v1/products",\n                json={\n                    "name": "E2E Test Product",\n                    "sku": "E2E-PRODUCT-001",\n                    "base_price": 100.0,\n                    "category_id": "cat-electronics"\n                },\n                headers={"X-Organization-ID": org_id}\n            )\n            assert product_response.status_code == 201\n            product = product_response.json()\n            product_id = product["product_id"]\n\n            # Crear variant\n            variant_response = await client.post(\n                f"/api/v1/products/{product_id}/variants",\n                json={\n                    "sku": "E2E-VAR-001",\n                    "name": "Default Variant",\n                    "price": 100.0\n                },\n                headers={"X-Organization-ID": org_id}\n            )\n            assert variant_response.status_code == 201\n            variant = variant_response.json()\n            variant_id = variant["variant_id"]\n\n        # 2. Crear stock en Inventory\n        async with AsyncClient(base_url=inventory_url) as client:\n            stock_response = await client.post(\n                "/api/v1/stock",\n                json={\n                    "variant_id": variant_id,\n                    "warehouse_id": "wh-main",\n                    "total_quantity": 100,\n                    "available_quantity": 100,\n                    "reserved_quantity": 0\n                },\n                headers={"X-Organization-ID": org_id}\n            )\n            assert stock_response.status_code == 201\n            stock = stock_response.json()\n\n        # Esperar propagaci\xf3n de eventos\n        await asyncio.sleep(2)\n\n        # 3. Crear orden\n        async with AsyncClient(base_url=order_url) as client:\n            order_response = await client.post(\n                "/api/v1/orders",\n                json={\n                    "customer_id": "cust-123",\n                    "items": [\n                        {\n                            "variant_id": variant_id,\n                            "quantity": 2,\n                            "unit_price": 100.0\n                        }\n                    ],\n                    "shipping_address": {\n                        "street": "123 Test St",\n                        "city": "Test City",\n                        "country": "US"\n                    }\n                },\n                headers={"X-Organization-ID": org_id}\n            )\n            assert order_response.status_code == 201\n            order = order_response.json()\n            order_id = order["order_id"]\n\n            assert order["status"] == "pending"\n            assert order["total_amount"] == 200.0\n\n        # Esperar reserva de stock (evento as\xedncrono)\n        await asyncio.sleep(2)\n\n        # 4. Verificar stock reservado\n        async with AsyncClient(base_url=inventory_url) as client:\n            stock_response = await client.get(\n                f"/api/v1/stock?variant_id={variant_id}",\n                headers={"X-Organization-ID": org_id}\n            )\n            assert stock_response.status_code == 200\n            updated_stock = stock_response.json()["items"][0]\n\n            assert updated_stock["reserved_quantity"] == 2\n            assert updated_stock["available_quantity"] == 98\n\n        # 5. Simular confirmaci\xf3n de pago\n        async with AsyncClient(base_url=order_url) as client:\n            payment_response = await client.post(\n                f"/api/v1/orders/{order_id}/payments",\n                json={\n                    "payment_method": "stripe",\n                    "amount": 200.0,\n                    "gateway_payment_id": "py_test_12345"\n                },\n                headers={"X-Organization-ID": org_id}\n            )\n            assert payment_response.status_code == 201\n\n        await asyncio.sleep(1)\n\n        # 6. Verificar orden confirmada\n        async with AsyncClient(base_url=order_url) as client:\n            order_get = await client.get(\n                f"/api/v1/orders/{order_id}",\n                headers={"X-Organization-ID": org_id}\n            )\n            updated_order = order_get.json()\n            assert updated_order["status"] == "confirmed"\n\n        # 7. Despachar orden\n        async with AsyncClient(base_url=order_url) as client:\n            ship_response = await client.post(\n                f"/api/v1/orders/{order_id}/ship",\n                json={\n                    "tracking_number": "TRACK-E2E-001",\n                    "carrier": "UPS"\n                },\n                headers={"X-Organization-ID": org_id}\n            )\n            assert ship_response.status_code == 200\n\n        await asyncio.sleep(2)\n\n        # 8. Verificar stock deducido\n        async with AsyncClient(base_url=inventory_url) as client:\n            stock_response = await client.get(\n                f"/api/v1/stock?variant_id={variant_id}",\n                headers={"X-Organization-ID": org_id}\n            )\n            final_stock = stock_response.json()["items"][0]\n\n            # Stock total y reservado deben haber disminuido\n            assert final_stock["total_quantity"] == 98\n            assert final_stock["reserved_quantity"] == 0\n            assert final_stock["available_quantity"] == 98\n\n        # 9. Verificar movement creado\n        async with AsyncClient(base_url=inventory_url) as client:\n            movements_response = await client.get(\n                f"/api/v1/movements?reference_id={order_id}",\n                headers={"X-Organization-ID": org_id}\n            )\n            movements = movements_response.json()["items"]\n\n            # Debe haber un movement de tipo "out"\n            assert len(movements) > 0\n            sale_movement = next(\n                m for m in movements if m["type"] == "out"\n            )\n            assert sale_movement["reason"] == "sale"\n            assert sale_movement["quantity"] == 2\n'})}),"\n",(0,r.jsx)(n.h4,{id:"test-e2e-flujo-de-devoluci\xf3n",children:"Test E2E: Flujo de Devoluci\xf3n"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# tests/e2e/test_return_flow.py\n@pytest.mark.e2e\n@pytest.mark.slow\nclass TestReturnFlow:\n    """E2E test del flujo de devoluci\xf3n."""\n\n    async def test_complete_return_workflow(self):\n        """\n        Test flujo de devoluci\xf3n:\n        1. Orden completada existente\n        2. Crear solicitud de devoluci\xf3n\n        3. Aprobar devoluci\xf3n\n        4. Recibir items\n        5. Re-stock inventory\n        6. Procesar reembolso\n        """\n        order_url = "http://localhost:8004"\n        inventory_url = "http://localhost:8003"\n        org_id = "e2e-org-return"\n\n        # Prerequisito: orden completada\n        order_id = await self._create_completed_order(org_id)\n        variant_id = "var-return-001"\n\n        # 1. Crear return request\n        async with AsyncClient(base_url=order_url) as client:\n            return_response = await client.post(\n                "/api/v1/returns",\n                json={\n                    "order_id": order_id,\n                    "items": [\n                        {\n                            "variant_id": variant_id,\n                            "quantity": 1,\n                            "reason": "defective"\n                        }\n                    ]\n                },\n                headers={"X-Organization-ID": org_id}\n            )\n            assert return_response.status_code == 201\n            return_obj = return_response.json()\n            return_id = return_obj["return_id"]\n            rma_number = return_obj["rma_number"]\n\n            assert return_obj["status"] == "pending"\n\n        # 2. Aprobar return\n        async with AsyncClient(base_url=order_url) as client:\n            approve_response = await client.post(\n                f"/api/v1/returns/{return_id}/approve",\n                headers={"X-Organization-ID": org_id}\n            )\n            assert approve_response.status_code == 200\n\n        # 3. Recibir items\n        async with AsyncClient(base_url=order_url) as client:\n            receive_response = await client.post(\n                f"/api/v1/returns/{return_id}/receive",\n                json={\n                    "items": [\n                        {\n                            "variant_id": variant_id,\n                            "quantity": 1,\n                            "condition": "good"\n                        }\n                    ]\n                },\n                headers={"X-Organization-ID": org_id}\n            )\n            assert receive_response.status_code == 200\n\n        await asyncio.sleep(2)\n\n        # 4. Verificar re-stock\n        async with AsyncClient(base_url=inventory_url) as client:\n            stock_response = await client.get(\n                f"/api/v1/stock?variant_id={variant_id}",\n                headers={"X-Organization-ID": org_id}\n            )\n            stock = stock_response.json()["items"][0]\n\n            # Stock debe haber aumentado\n            # (dependiente del stock inicial)\n            assert stock["total_quantity"] > 0\n\n        # 5. Verificar refund procesado\n        async with AsyncClient(base_url=order_url) as client:\n            return_get = await client.get(\n                f"/api/v1/returns/{return_id}",\n                headers={"X-Organization-ID": org_id}\n            )\n            final_return = return_get.json()\n\n            assert final_return["status"] == "completed"\n            assert final_return["refund_amount"] > 0\n'})}),"\n",(0,r.jsx)(n.h2,{id:"estrategia-de-ejecuci\xf3n",children:"Estrategia de Ejecuci\xf3n"}),"\n",(0,r.jsx)(n.h3,{id:"cicd-pipeline",children:"CI/CD Pipeline"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"# .github/workflows/test.yml\nname: Test Suite\n\non: [push, pull_request]\n\njobs:\n  unit-tests:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        service: [auth, catalog, inventory, order, audit]\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.11'\n\n      - name: Install dependencies\n        run: |\n          cd services/${{ matrix.service }}-service\n          pip install -r requirements.txt\n          pip install -r requirements-dev.txt\n\n      - name: Run unit tests\n        run: |\n          cd services/${{ matrix.service }}-service\n          pytest tests/unit -v --cov --cov-report=xml -m unit\n\n      - name: Upload coverage\n        uses: codecov/codecov-action@v3\n        with:\n          file: ./coverage.xml\n\n  integration-tests:\n    runs-on: ubuntu-latest\n    needs: unit-tests\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.11'\n\n      - name: Start test containers\n        run: |\n          docker-compose -f docker-compose.test.yml up -d\n\n      - name: Run integration tests\n        run: |\n          pytest tests/integration -v -m integration\n\n      - name: Cleanup\n        run: docker-compose -f docker-compose.test.yml down\n\n  e2e-tests:\n    runs-on: ubuntu-latest\n    needs: integration-tests\n    if: github.ref == 'refs/heads/main' || github.event_name == 'pull_request'\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Build services\n        run: docker-compose -f docker-compose.test.yml build\n\n      - name: Start all services\n        run: docker-compose -f docker-compose.test.yml up -d\n\n      - name: Wait for services\n        run: ./scripts/wait-for-services.sh\n\n      - name: Run E2E tests\n        run: pytest tests/e2e -v -m e2e\n\n      - name: Cleanup\n        run: docker-compose -f docker-compose.test.yml down -v\n"})}),"\n",(0,r.jsx)(n.h3,{id:"comandos-locales",children:"Comandos Locales"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Ejecutar solo unit tests\npytest tests/unit -v -m unit\n\n# Ejecutar integration tests con containers\ndocker-compose -f docker-compose.test.yml up -d\npytest tests/integration -v -m integration\ndocker-compose -f docker-compose.test.yml down\n\n# Ejecutar E2E tests\ndocker-compose -f docker-compose.test.yml up -d --build\npytest tests/e2e -v -m e2e\ndocker-compose -f docker-compose.test.yml down -v\n\n# Coverage completo\npytest --cov=src --cov-report=html --cov-report=term\n\n# Tests espec\xedficos\npytest tests/unit/test_pricing_service.py::TestPricingService::test_calculate_price_with_volume_discount -v\n"})}),"\n",(0,r.jsx)(n.h2,{id:"m\xe9tricas-de-calidad",children:"M\xe9tricas de Calidad"}),"\n",(0,r.jsx)(n.h3,{id:"cobertura-m\xednima",children:"Cobertura M\xednima"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Nivel"}),(0,r.jsx)(n.th,{children:"Cobertura M\xednima"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Unit Tests"}),(0,r.jsx)(n.td,{children:"80%"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Integration Tests"}),(0,r.jsx)(n.td,{children:"60%"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"E2E Tests"}),(0,r.jsx)(n.td,{children:"Critical paths"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"performance-benchmarks",children:"Performance Benchmarks"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Tipo de Test"}),(0,r.jsx)(n.th,{children:"Tiempo M\xe1ximo"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Unit test individual"}),(0,r.jsx)(n.td,{children:"10ms"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Integration test"}),(0,r.jsx)(n.td,{children:"1s"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"E2E test"}),(0,r.jsx)(n.td,{children:"30s"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Suite completa (CI)"}),(0,r.jsx)(n.td,{children:"10 min"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"pr\xf3ximos-pasos",children:"Pr\xf3ximos Pasos"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/testing/observability",children:"Gu\xeda de Observabilidad"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/testing/error-handling",children:"Manejo de Errores"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/testing/performance",children:"Performance Testing"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);