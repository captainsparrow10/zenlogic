"use strict";(globalThis.webpackChunkerp_docs=globalThis.webpackChunkerp_docs||[]).push([[9712],{8308:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"observabilidad/guia-observabilidad","title":"Gu\xeda de Observabilidad","description":"Sistema completo de observabilidad para microservicios: logging, m\xe9tricas y tracing distribuido.","source":"@site/docs/06-observabilidad/01-guia-observabilidad.md","sourceDirName":"06-observabilidad","slug":"/observabilidad/guia-observabilidad","permalink":"/zenlogic/observabilidad/guia-observabilidad","draft":false,"unlisted":false,"editUrl":"https://github.com/your-repo/edit/main/docs/06-observabilidad/01-guia-observabilidad.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1}}');var a=t(4848),s=t(8453);const i={sidebar_position:1},o="Gu\xeda de Observabilidad",c={},d=[{value:"Los Tres Pilares",id:"los-tres-pilares",level:2},{value:"1. Logging Estructurado",id:"1-logging-estructurado",level:2},{value:"Configuraci\xf3n con Structlog",id:"configuraci\xf3n-con-structlog",level:3},{value:"Uso en la Aplicaci\xf3n",id:"uso-en-la-aplicaci\xf3n",level:3},{value:"Middleware de Request Logging",id:"middleware-de-request-logging",level:3},{value:"Logging de Eventos",id:"logging-de-eventos",level:3},{value:"Formato de Logs en Producci\xf3n",id:"formato-de-logs-en-producci\xf3n",level:3},{value:"2. M\xe9tricas con Prometheus",id:"2-m\xe9tricas-con-prometheus",level:2},{value:"Setup de Prometheus Client",id:"setup-de-prometheus-client",level:3},{value:"Middleware de M\xe9tricas",id:"middleware-de-m\xe9tricas",level:3},{value:"Uso en Servicios",id:"uso-en-servicios",level:3},{value:"M\xe9tricas de Eventos",id:"m\xe9tricas-de-eventos",level:3},{value:"Configuraci\xf3n de Prometheus",id:"configuraci\xf3n-de-prometheus",level:3},{value:"Alertas de Prometheus",id:"alertas-de-prometheus",level:3},{value:"3. Distributed Tracing con Jaeger",id:"3-distributed-tracing-con-jaeger",level:2},{value:"Setup de OpenTelemetry",id:"setup-de-opentelemetry",level:3},{value:"Uso en la Aplicaci\xf3n",id:"uso-en-la-aplicaci\xf3n-1",level:3},{value:"Tracing Manual de Operaciones",id:"tracing-manual-de-operaciones",level:3},{value:"Propagaci\xf3n de Context en gRPC",id:"propagaci\xf3n-de-context-en-grpc",level:3},{value:"Tracing de Event Consumers",id:"tracing-de-event-consumers",level:3},{value:"4. Dashboards de Grafana",id:"4-dashboards-de-grafana",level:2},{value:"Dashboard de Overview",id:"dashboard-de-overview",level:3},{value:"Dashboard de Order Service",id:"dashboard-de-order-service",level:3},{value:"Pr\xf3ximos Pasos",id:"pr\xf3ximos-pasos",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"gu\xeda-de-observabilidad",children:"Gu\xeda de Observabilidad"})}),"\n",(0,a.jsx)(n.p,{children:"Sistema completo de observabilidad para microservicios: logging, m\xe9tricas y tracing distribuido."}),"\n",(0,a.jsx)(n.h2,{id:"los-tres-pilares",children:"Los Tres Pilares"}),"\n",(0,a.jsx)(n.mermaid,{value:'graph LR\n    subgraph "Observabilidad"\n        L[Logs<br/>Qu\xe9 pas\xf3]\n        M[M\xe9tricas<br/>Cu\xe1ndo y cu\xe1nto]\n        T[Traces<br/>D\xf3nde y por qu\xe9]\n    end\n\n    L --\x3e Loki[Loki/ELK]\n    M --\x3e Prom[Prometheus]\n    T --\x3e Jaeger[Jaeger]\n\n    Loki --\x3e Grafana\n    Prom --\x3e Grafana\n    Jaeger --\x3e Grafana\n\n    style L fill:#90EE90\n    style M fill:#FFD700\n    style T fill:#87CEEB'}),"\n",(0,a.jsx)(n.h2,{id:"1-logging-estructurado",children:"1. Logging Estructurado"}),"\n",(0,a.jsx)(n.h3,{id:"configuraci\xf3n-con-structlog",children:"Configuraci\xf3n con Structlog"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# src/logging_config.py\nimport structlog\nimport logging\nimport sys\nfrom typing import Any\n\ndef setup_logging(\n    service_name: str,\n    environment: str,\n    log_level: str = "INFO"\n) -> None:\n    """Configurar logging estructurado con structlog."""\n\n    # Procesadores de structlog\n    shared_processors = [\n        structlog.contextvars.merge_contextvars,\n        structlog.stdlib.add_log_level,\n        structlog.stdlib.add_logger_name,\n        structlog.processors.TimeStamper(fmt="iso"),\n        structlog.processors.StackInfoRenderer(),\n        structlog.processors.format_exc_info,\n        structlog.processors.UnicodeDecoder(),\n    ]\n\n    # Configuraci\xf3n para producci\xf3n (JSON)\n    if environment == "production":\n        structlog.configure(\n            processors=shared_processors + [\n                structlog.processors.dict_tracebacks,\n                structlog.processors.JSONRenderer()\n            ],\n            wrapper_class=structlog.stdlib.BoundLogger,\n            context_class=dict,\n            logger_factory=structlog.stdlib.LoggerFactory(),\n            cache_logger_on_first_use=True,\n        )\n    # Configuraci\xf3n para desarrollo (human-readable)\n    else:\n        structlog.configure(\n            processors=shared_processors + [\n                structlog.dev.ConsoleRenderer()\n            ],\n            wrapper_class=structlog.stdlib.BoundLogger,\n            context_class=dict,\n            logger_factory=structlog.stdlib.LoggerFactory(),\n            cache_logger_on_first_use=True,\n        )\n\n    # Configurar logging est\xe1ndar\n    logging.basicConfig(\n        format="%(message)s",\n        stream=sys.stdout,\n        level=getattr(logging, log_level.upper()),\n    )\n\n    # Log de inicio\n    logger = structlog.get_logger()\n    logger.info(\n        "logging_configured",\n        service=service_name,\n        environment=environment,\n        log_level=log_level\n    )\n'})}),"\n",(0,a.jsx)(n.h3,{id:"uso-en-la-aplicaci\xf3n",children:"Uso en la Aplicaci\xf3n"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# src/services/product_service.py\nimport structlog\n\nlogger = structlog.get_logger(__name__)\n\nclass ProductService:\n    """Servicio de productos con logging estructurado."""\n\n    async def create_product(\n        self,\n        organization_id: str,\n        product_data: dict,\n        user_id: str\n    ) -> Product:\n        """Crear producto con logging completo."""\n\n        # Bind context para todos los logs subsecuentes\n        log = logger.bind(\n            organization_id=organization_id,\n            user_id=user_id,\n            operation="create_product"\n        )\n\n        log.info(\n            "product_creation_started",\n            product_name=product_data.get("name"),\n            sku=product_data.get("sku")\n        )\n\n        try:\n            # Validar SKU \xfanico\n            existing = await self.repo.get_by_sku(\n                product_data["sku"],\n                organization_id\n            )\n\n            if existing:\n                log.warning(\n                    "product_creation_failed_duplicate_sku",\n                    sku=product_data["sku"],\n                    existing_product_id=existing.product_id\n                )\n                raise DuplicateSKUError(f"SKU {product_data[\'sku\']} already exists")\n\n            # Crear producto\n            product = await self.repo.create(product_data)\n\n            log.info(\n                "product_created_successfully",\n                product_id=product.product_id,\n                sku=product.sku,\n                name=product.name\n            )\n\n            # Publicar evento\n            await self.event_publisher.publish(\n                ProductCreatedEvent(\n                    product_id=product.product_id,\n                    organization_id=organization_id,\n                    **product_data\n                )\n            )\n\n            return product\n\n        except DuplicateSKUError:\n            raise\n\n        except Exception as e:\n            log.error(\n                "product_creation_failed",\n                error=str(e),\n                error_type=type(e).__name__,\n                exc_info=True\n            )\n            raise\n'})}),"\n",(0,a.jsx)(n.h3,{id:"middleware-de-request-logging",children:"Middleware de Request Logging"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# src/middleware/logging_middleware.py\nimport structlog\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.requests import Request\nimport time\nimport uuid\n\nlogger = structlog.get_logger(__name__)\n\nclass RequestLoggingMiddleware(BaseHTTPMiddleware):\n    """Middleware para logging de requests HTTP."""\n\n    async def dispatch(self, request: Request, call_next):\n        # Generar request ID\n        request_id = str(uuid.uuid4())\n        request.state.request_id = request_id\n\n        # Bind context\n        log = logger.bind(\n            request_id=request_id,\n            method=request.method,\n            path=request.url.path,\n            client_ip=request.client.host,\n            user_agent=request.headers.get("user-agent")\n        )\n\n        # Extraer organization_id de header\n        org_id = request.headers.get("X-Organization-ID")\n        if org_id:\n            log = log.bind(organization_id=org_id)\n\n        # Log de inicio\n        log.info("request_started")\n\n        start_time = time.time()\n\n        try:\n            response = await call_next(request)\n            duration = time.time() - start_time\n\n            # Log de \xe9xito\n            log.info(\n                "request_completed",\n                status_code=response.status_code,\n                duration_ms=round(duration * 1000, 2)\n            )\n\n            # Agregar headers de tracing\n            response.headers["X-Request-ID"] = request_id\n\n            return response\n\n        except Exception as e:\n            duration = time.time() - start_time\n\n            # Log de error\n            log.error(\n                "request_failed",\n                error=str(e),\n                error_type=type(e).__name__,\n                duration_ms=round(duration * 1000, 2),\n                exc_info=True\n            )\n            raise\n'})}),"\n",(0,a.jsx)(n.h3,{id:"logging-de-eventos",children:"Logging de Eventos"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# src/events/consumer.py\nimport structlog\n\nlogger = structlog.get_logger(__name__)\n\nclass EventConsumer:\n    """Consumer de eventos con logging."""\n\n    async def handle_message(self, message: dict) -> None:\n        """Procesar mensaje con logging completo."""\n\n        event_id = message.get("event_id")\n        event_type = message.get("event_type")\n\n        log = logger.bind(\n            event_id=event_id,\n            event_type=event_type,\n            organization_id=message.get("organization_id")\n        )\n\n        log.info("event_received")\n\n        try:\n            # Verificar idempotencia\n            if await self.is_duplicate(event_id):\n                log.warning(\n                    "event_duplicate_ignored",\n                    event_id=event_id\n                )\n                return\n\n            # Procesar evento\n            handler = self.handlers.get(event_type)\n            if not handler:\n                log.warning(\n                    "event_handler_not_found",\n                    event_type=event_type\n                )\n                return\n\n            await handler(message)\n\n            log.info("event_processed_successfully")\n\n        except Exception as e:\n            log.error(\n                "event_processing_failed",\n                error=str(e),\n                error_type=type(e).__name__,\n                exc_info=True\n            )\n            # Re-raise para retry\n            raise\n'})}),"\n",(0,a.jsx)(n.h3,{id:"formato-de-logs-en-producci\xf3n",children:"Formato de Logs en Producci\xf3n"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "event": "product_created_successfully",\n  "timestamp": "2025-11-23T10:30:45.123456Z",\n  "level": "info",\n  "logger": "src.services.product_service",\n  "service": "catalog-service",\n  "environment": "production",\n  "organization_id": "org-abc-123",\n  "user_id": "user-xyz-789",\n  "request_id": "req-uuid-456",\n  "operation": "create_product",\n  "product_id": "prod-def-321",\n  "sku": "LAPTOP-15-001",\n  "name": "Dell Laptop 15\\"",\n  "duration_ms": 125.45\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"2-m\xe9tricas-con-prometheus",children:"2. M\xe9tricas con Prometheus"}),"\n",(0,a.jsx)(n.h3,{id:"setup-de-prometheus-client",children:"Setup de Prometheus Client"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# src/metrics.py\nfrom prometheus_client import (\n    Counter,\n    Histogram,\n    Gauge,\n    Info,\n    generate_latest,\n    REGISTRY\n)\nfrom starlette.responses import Response\n\n# M\xe9tricas de HTTP requests\nhttp_requests_total = Counter(\n    "http_requests_total",\n    "Total HTTP requests",\n    ["method", "endpoint", "status_code", "organization_id"]\n)\n\nhttp_request_duration_seconds = Histogram(\n    "http_request_duration_seconds",\n    "HTTP request duration in seconds",\n    ["method", "endpoint"],\n    buckets=[0.01, 0.05, 0.1, 0.5, 1.0, 2.5, 5.0, 10.0]\n)\n\n# M\xe9tricas de negocio\nproducts_created_total = Counter(\n    "products_created_total",\n    "Total products created",\n    ["organization_id"]\n)\n\norders_total = Counter(\n    "orders_total",\n    "Total orders",\n    ["organization_id", "status"]\n)\n\norder_value_dollars = Histogram(\n    "order_value_dollars",\n    "Order value in dollars",\n    ["organization_id"],\n    buckets=[10, 50, 100, 500, 1000, 5000, 10000]\n)\n\n# M\xe9tricas de stock\nstock_level = Gauge(\n    "stock_level",\n    "Current stock level",\n    ["variant_id", "warehouse_id", "organization_id"]\n)\n\nstock_reservations_active = Gauge(\n    "stock_reservations_active",\n    "Active stock reservations",\n    ["warehouse_id", "organization_id"]\n)\n\n# M\xe9tricas de eventos\nevents_published_total = Counter(\n    "events_published_total",\n    "Total events published",\n    ["event_type", "service"]\n)\n\nevents_consumed_total = Counter(\n    "events_consumed_total",\n    "Total events consumed",\n    ["event_type", "service", "status"]\n)\n\nevent_processing_duration_seconds = Histogram(\n    "event_processing_duration_seconds",\n    "Event processing duration",\n    ["event_type"],\n    buckets=[0.01, 0.1, 0.5, 1.0, 5.0, 10.0]\n)\n\n# M\xe9tricas de database\ndb_connections_active = Gauge(\n    "db_connections_active",\n    "Active database connections"\n)\n\ndb_query_duration_seconds = Histogram(\n    "db_query_duration_seconds",\n    "Database query duration",\n    ["query_type"],\n    buckets=[0.001, 0.01, 0.05, 0.1, 0.5, 1.0]\n)\n\n# Informaci\xf3n del servicio\nservice_info = Info(\n    "service",\n    "Service information"\n)\n\n# Endpoint para Prometheus\nasync def metrics_endpoint():\n    """Endpoint /metrics para Prometheus."""\n    return Response(\n        content=generate_latest(REGISTRY),\n        media_type="text/plain"\n    )\n'})}),"\n",(0,a.jsx)(n.h3,{id:"middleware-de-m\xe9tricas",children:"Middleware de M\xe9tricas"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# src/middleware/metrics_middleware.py\nfrom prometheus_client import Histogram\nimport time\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom src.metrics import (\n    http_requests_total,\n    http_request_duration_seconds\n)\n\nclass MetricsMiddleware(BaseHTTPMiddleware):\n    """Middleware para recolectar m\xe9tricas HTTP."""\n\n    async def dispatch(self, request, call_next):\n        # Extraer datos\n        method = request.method\n        path = request.url.path\n        org_id = request.headers.get("X-Organization-ID", "unknown")\n\n        # Timing\n        start_time = time.time()\n\n        try:\n            response = await call_next(request)\n            duration = time.time() - start_time\n\n            # Registrar m\xe9tricas\n            http_requests_total.labels(\n                method=method,\n                endpoint=path,\n                status_code=response.status_code,\n                organization_id=org_id\n            ).inc()\n\n            http_request_duration_seconds.labels(\n                method=method,\n                endpoint=path\n            ).observe(duration)\n\n            return response\n\n        except Exception as e:\n            duration = time.time() - start_time\n\n            # M\xe9trica de error\n            http_requests_total.labels(\n                method=method,\n                endpoint=path,\n                status_code=500,\n                organization_id=org_id\n            ).inc()\n\n            raise\n'})}),"\n",(0,a.jsx)(n.h3,{id:"uso-en-servicios",children:"Uso en Servicios"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# src/services/product_service.py\nfrom src.metrics import (\n    products_created_total,\n    db_query_duration_seconds\n)\nimport time\n\nclass ProductService:\n    """Servicio con m\xe9tricas."""\n\n    async def create_product(\n        self,\n        organization_id: str,\n        product_data: dict\n    ) -> Product:\n        """Crear producto y registrar m\xe9tricas."""\n\n        # Timing de DB query\n        start_time = time.time()\n\n        product = await self.repo.create(product_data)\n\n        duration = time.time() - start_time\n        db_query_duration_seconds.labels(\n            query_type="insert_product"\n        ).observe(duration)\n\n        # Contador de productos creados\n        products_created_total.labels(\n            organization_id=organization_id\n        ).inc()\n\n        return product\n\n    async def get_low_stock_products(\n        self,\n        organization_id: str,\n        threshold: int = 10\n    ) -> list[Product]:\n        """Obtener productos con stock bajo."""\n\n        products = await self.repo.get_low_stock(threshold)\n\n        # Actualizar gauge de stock\n        for product in products:\n            for variant in product.variants:\n                stock_level.labels(\n                    variant_id=variant.variant_id,\n                    warehouse_id=variant.stock.warehouse_id,\n                    organization_id=organization_id\n                ).set(variant.stock.available_quantity)\n\n        return products\n'})}),"\n",(0,a.jsx)(n.h3,{id:"m\xe9tricas-de-eventos",children:"M\xe9tricas de Eventos"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# src/events/publisher.py\nfrom src.metrics import events_published_total\nimport time\n\nclass EventPublisher:\n    """Publisher con m\xe9tricas."""\n\n    async def publish(\n        self,\n        exchange: str,\n        routing_key: str,\n        event: dict\n    ) -> None:\n        """Publicar evento y registrar m\xe9trica."""\n\n        event_type = event.get("event_type")\n\n        await self._publish_to_rabbitmq(exchange, routing_key, event)\n\n        # Incrementar contador\n        events_published_total.labels(\n            event_type=event_type,\n            service=self.service_name\n        ).inc()\n\n# src/events/consumer.py\nfrom src.metrics import (\n    events_consumed_total,\n    event_processing_duration_seconds\n)\n\nclass EventConsumer:\n    """Consumer con m\xe9tricas."""\n\n    async def handle_message(self, message: dict) -> None:\n        """Procesar mensaje y registrar m\xe9tricas."""\n\n        event_type = message.get("event_type")\n        start_time = time.time()\n\n        try:\n            await self._process_event(message)\n\n            # M\xe9trica de \xe9xito\n            events_consumed_total.labels(\n                event_type=event_type,\n                service=self.service_name,\n                status="success"\n            ).inc()\n\n        except Exception as e:\n            # M\xe9trica de error\n            events_consumed_total.labels(\n                event_type=event_type,\n                service=self.service_name,\n                status="error"\n            ).inc()\n            raise\n\n        finally:\n            # Duraci\xf3n\n            duration = time.time() - start_time\n            event_processing_duration_seconds.labels(\n                event_type=event_type\n            ).observe(duration)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"configuraci\xf3n-de-prometheus",children:"Configuraci\xf3n de Prometheus"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"# prometheus/prometheus.yml\nglobal:\n  scrape_interval: 15s\n  evaluation_interval: 15s\n  external_labels:\n    cluster: 'erp-production'\n    environment: 'prod'\n\nscrape_configs:\n  # Auth Service\n  - job_name: 'auth-service'\n    static_configs:\n      - targets: ['auth-service:8001']\n    metrics_path: '/metrics'\n    scrape_interval: 10s\n\n  # Catalog Service\n  - job_name: 'catalog-service'\n    static_configs:\n      - targets: ['catalog-service:8002']\n    metrics_path: '/metrics'\n\n  # Inventory Service\n  - job_name: 'inventory-service'\n    static_configs:\n      - targets: ['inventory-service:8003']\n    metrics_path: '/metrics'\n\n  # Order Service\n  - job_name: 'order-service'\n    static_configs:\n      - targets: ['order-service:8004']\n    metrics_path: '/metrics'\n\n  # Audit Service\n  - job_name: 'audit-service'\n    static_configs:\n      - targets: ['audit-service:8005']\n    metrics_path: '/metrics'\n\n  # PostgreSQL Exporter\n  - job_name: 'postgres'\n    static_configs:\n      - targets: ['postgres-exporter:9187']\n\n  # Redis Exporter\n  - job_name: 'redis'\n    static_configs:\n      - targets: ['redis-exporter:9121']\n\n  # RabbitMQ\n  - job_name: 'rabbitmq'\n    static_configs:\n      - targets: ['rabbitmq:15692']\n\n# Alerting rules\nrule_files:\n  - 'alerts.yml'\n\nalerting:\n  alertmanagers:\n    - static_configs:\n        - targets: ['alertmanager:9093']\n"})}),"\n",(0,a.jsx)(n.h3,{id:"alertas-de-prometheus",children:"Alertas de Prometheus"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'# prometheus/alerts.yml\ngroups:\n  - name: erp_alerts\n    interval: 30s\n    rules:\n      # Alta latencia en requests\n      - alert: HighRequestLatency\n        expr: |\n          histogram_quantile(0.95,\n            rate(http_request_duration_seconds_bucket[5m])\n          ) > 2\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: "High request latency on {{ $labels.instance }}"\n          description: "95th percentile latency is {{ $value }}s"\n\n      # Alto error rate\n      - alert: HighErrorRate\n        expr: |\n          rate(http_requests_total{status_code=~"5.."}[5m])\n          /\n          rate(http_requests_total[5m])\n          > 0.05\n        for: 5m\n        labels:\n          severity: critical\n        annotations:\n          summary: "High error rate on {{ $labels.instance }}"\n          description: "Error rate is {{ $value | humanizePercentage }}"\n\n      # Stock bajo\n      - alert: LowStockLevel\n        expr: stock_level < 10\n        for: 1h\n        labels:\n          severity: warning\n        annotations:\n          summary: "Low stock for variant {{ $labels.variant_id }}"\n          description: "Only {{ $value }} units remaining"\n\n      # Reservas acumuladas\n      - alert: HighReservationBacklog\n        expr: stock_reservations_active > 1000\n        for: 10m\n        labels:\n          severity: warning\n        annotations:\n          summary: "High number of active reservations"\n          description: "{{ $value }} active reservations"\n\n      # Event processing lento\n      - alert: SlowEventProcessing\n        expr: |\n          histogram_quantile(0.95,\n            rate(event_processing_duration_seconds_bucket[5m])\n          ) > 5\n        for: 10m\n        labels:\n          severity: warning\n        annotations:\n          summary: "Slow event processing for {{ $labels.event_type }}"\n          description: "95th percentile is {{ $value }}s"\n\n      # Database connections\n      - alert: HighDatabaseConnections\n        expr: db_connections_active > 80\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: "High number of database connections"\n          description: "{{ $value }} active connections"\n'})}),"\n",(0,a.jsx)(n.h2,{id:"3-distributed-tracing-con-jaeger",children:"3. Distributed Tracing con Jaeger"}),"\n",(0,a.jsx)(n.h3,{id:"setup-de-opentelemetry",children:"Setup de OpenTelemetry"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# src/tracing.py\nfrom opentelemetry import trace\nfrom opentelemetry.exporter.jaeger.thrift import JaegerExporter\nfrom opentelemetry.sdk.resources import Resource\nfrom opentelemetry.sdk.trace import TracerProvider\nfrom opentelemetry.sdk.trace.export import BatchSpanProcessor\nfrom opentelemetry.instrumentation.fastapi import FastAPIInstrumentor\nfrom opentelemetry.instrumentation.sqlalchemy import SQLAlchemyInstrumentor\nfrom opentelemetry.instrumentation.redis import RedisInstrumentor\nfrom opentelemetry.instrumentation.httpx import HTTPXClientInstrumentor\n\ndef setup_tracing(\n    service_name: str,\n    jaeger_host: str = "jaeger",\n    jaeger_port: int = 6831\n) -> None:\n    """Configurar distributed tracing con Jaeger."""\n\n    # Resource con informaci\xf3n del servicio\n    resource = Resource.create({\n        "service.name": service_name,\n        "service.version": "1.0.0",\n        "deployment.environment": "production"\n    })\n\n    # Tracer provider\n    provider = TracerProvider(resource=resource)\n\n    # Jaeger exporter\n    jaeger_exporter = JaegerExporter(\n        agent_host_name=jaeger_host,\n        agent_port=jaeger_port,\n    )\n\n    # Span processor\n    processor = BatchSpanProcessor(jaeger_exporter)\n    provider.add_span_processor(processor)\n\n    # Set global tracer provider\n    trace.set_tracer_provider(provider)\n\ndef instrument_app(app, engine, redis_client) -> None:\n    """Instrumentar aplicaci\xf3n y dependencias."""\n\n    # FastAPI auto-instrumentation\n    FastAPIInstrumentor.instrument_app(app)\n\n    # SQLAlchemy instrumentation\n    SQLAlchemyInstrumentor().instrument(engine=engine.sync_engine)\n\n    # Redis instrumentation\n    RedisInstrumentor().instrument(redis_client=redis_client)\n\n    # HTTPX (para llamadas gRPC/HTTP)\n    HTTPXClientInstrumentor().instrument()\n'})}),"\n",(0,a.jsx)(n.h3,{id:"uso-en-la-aplicaci\xf3n-1",children:"Uso en la Aplicaci\xf3n"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# src/main.py\nfrom fastapi import FastAPI\nfrom src.tracing import setup_tracing, instrument_app\nfrom src.database import engine\nfrom src.cache import redis_client\n\napp = FastAPI()\n\n# Setup tracing\nsetup_tracing(service_name="catalog-service")\ninstrument_app(app, engine, redis_client)\n\n@app.on_event("startup")\nasync def startup():\n    # Tracing ya configurado autom\xe1ticamente\n    pass\n'})}),"\n",(0,a.jsx)(n.h3,{id:"tracing-manual-de-operaciones",children:"Tracing Manual de Operaciones"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# src/services/order_service.py\nfrom opentelemetry import trace\n\ntracer = trace.get_tracer(__name__)\n\nclass OrderService:\n    """Servicio con tracing manual."""\n\n    async def create_order(\n        self,\n        organization_id: str,\n        order_data: dict\n    ) -> Order:\n        """Crear orden con tracing detallado."""\n\n        with tracer.start_as_current_span("create_order") as span:\n            # Agregar atributos al span\n            span.set_attribute("organization_id", organization_id)\n            span.set_attribute("customer_id", order_data["customer_id"])\n            span.set_attribute("items_count", len(order_data["items"]))\n\n            # 1. Validar items\n            with tracer.start_as_current_span("validate_items"):\n                await self._validate_items(order_data["items"])\n\n            # 2. Calcular totales\n            with tracer.start_as_current_span("calculate_totals") as calc_span:\n                total = await self._calculate_total(order_data["items"])\n                calc_span.set_attribute("total_amount", float(total))\n\n            # 3. Crear orden en BD\n            with tracer.start_as_current_span("database.insert_order"):\n                order = await self.repo.create({\n                    **order_data,\n                    "total_amount": total\n                })\n\n            # 4. Reservar stock (gRPC call - auto-traced)\n            with tracer.start_as_current_span("inventory.reserve_stock") as inv_span:\n                reservation = await self.inventory_client.reserve_stock(\n                    organization_id=organization_id,\n                    order_id=order.order_id,\n                    items=order_data["items"]\n                )\n                inv_span.set_attribute("reservation_id", reservation.reservation_id)\n\n            # 5. Publicar evento\n            with tracer.start_as_current_span("events.publish_order_created"):\n                await self.event_publisher.publish(\n                    OrderCreatedEvent(\n                        order_id=order.order_id,\n                        organization_id=organization_id,\n                        total_amount=total\n                    )\n                )\n\n            span.set_attribute("order_id", str(order.order_id))\n            span.set_attribute("order_status", order.status)\n\n            return order\n'})}),"\n",(0,a.jsx)(n.h3,{id:"propagaci\xf3n-de-context-en-grpc",children:"Propagaci\xf3n de Context en gRPC"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# src/grpc/client.py\nfrom opentelemetry import trace\nfrom opentelemetry.propagate import inject\nimport grpc\n\ntracer = trace.get_tracer(__name__)\n\nclass InventoryGRPCClient:\n    """Cliente gRPC con propagaci\xf3n de tracing context."""\n\n    async def reserve_stock(\n        self,\n        organization_id: str,\n        order_id: str,\n        items: list\n    ):\n        """Reservar stock con context propagation."""\n\n        with tracer.start_as_current_span(\n            "grpc.inventory.reserve_stock"\n        ) as span:\n            # Preparar metadata para propagaci\xf3n\n            metadata = {}\n            inject(metadata)  # Inyecta trace context\n\n            # Agregar org_id\n            metadata["organization-id"] = organization_id\n\n            # Llamada gRPC\n            async with grpc.aio.insecure_channel(\n                f"{self.host}:{self.port}"\n            ) as channel:\n                stub = inventory_pb2_grpc.InventoryServiceStub(channel)\n\n                request = inventory_pb2.ReserveStockRequest(\n                    organization_id=organization_id,\n                    order_id=order_id,\n                    items=[\n                        inventory_pb2.ReserveItem(\n                            variant_id=item["variant_id"],\n                            quantity=item["quantity"]\n                        )\n                        for item in items\n                    ]\n                )\n\n                response = await stub.ReserveStock(\n                    request,\n                    metadata=list(metadata.items())\n                )\n\n                span.set_attribute("reservation_id", response.reservation_id)\n                span.set_attribute("items_reserved", len(items))\n\n                return response\n\n# src/grpc/server.py\nfrom opentelemetry.propagate import extract\n\nclass InventoryServicer(inventory_pb2_grpc.InventoryServiceServicer):\n    """Servidor gRPC que extrae tracing context."""\n\n    async def ReserveStock(self, request, context):\n        """Reservar stock con context extraction."""\n\n        # Extraer metadata\n        metadata = dict(context.invocation_metadata())\n\n        # Extraer trace context\n        ctx = extract(metadata)\n\n        # Usar context extra\xeddo\n        with tracer.start_as_current_span(\n            "inventory.reserve_stock_handler",\n            context=ctx\n        ) as span:\n            span.set_attribute("organization_id", request.organization_id)\n            span.set_attribute("order_id", request.order_id)\n\n            # Procesar reserva\n            reservation = await self.service.reserve_stock(\n                organization_id=request.organization_id,\n                order_id=request.order_id,\n                items=request.items\n            )\n\n            return inventory_pb2.ReserveStockResponse(\n                reservation_id=reservation.reservation_id,\n                status="success"\n            )\n'})}),"\n",(0,a.jsx)(n.h3,{id:"tracing-de-event-consumers",children:"Tracing de Event Consumers"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# src/events/consumer.py\nfrom opentelemetry import trace\nfrom opentelemetry.propagate import extract, inject\n\ntracer = trace.get_tracer(__name__)\n\nclass EventConsumer:\n    """Consumer con distributed tracing."""\n\n    async def handle_message(self, message: dict) -> None:\n        """Procesar mensaje con context propagation."""\n\n        # Extraer trace context del mensaje\n        # (debe ser inyectado por el publisher)\n        trace_context = message.get("_trace_context", {})\n        ctx = extract(trace_context)\n\n        event_type = message.get("event_type")\n        event_id = message.get("event_id")\n\n        with tracer.start_as_current_span(\n            f"consume.{event_type}",\n            context=ctx\n        ) as span:\n            span.set_attribute("event_id", event_id)\n            span.set_attribute("event_type", event_type)\n            span.set_attribute("organization_id", message.get("organization_id"))\n\n            try:\n                handler = self.handlers.get(event_type)\n\n                if not handler:\n                    span.set_status(trace.Status(trace.StatusCode.ERROR))\n                    span.set_attribute("error", "handler_not_found")\n                    return\n\n                await handler(message)\n\n                span.set_status(trace.Status(trace.StatusCode.OK))\n\n            except Exception as e:\n                span.set_status(trace.Status(trace.StatusCode.ERROR))\n                span.record_exception(e)\n                raise\n\n# Publisher que inyecta context\nclass EventPublisher:\n    """Publisher que propaga trace context."""\n\n    async def publish(self, exchange: str, routing_key: str, event: dict):\n        """Publicar evento con trace context."""\n\n        with tracer.start_as_current_span("publish." + event["event_type"]) as span:\n            # Inyectar trace context en el mensaje\n            trace_context = {}\n            inject(trace_context)\n\n            event["_trace_context"] = trace_context\n\n            await self._publish_to_rabbitmq(exchange, routing_key, event)\n\n            span.set_attribute("event_id", event["event_id"])\n            span.set_attribute("routing_key", routing_key)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"4-dashboards-de-grafana",children:"4. Dashboards de Grafana"}),"\n",(0,a.jsx)(n.h3,{id:"dashboard-de-overview",children:"Dashboard de Overview"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "dashboard": {\n    "title": "ERP Microservices Overview",\n    "panels": [\n      {\n        "title": "Request Rate",\n        "targets": [\n          {\n            "expr": "sum(rate(http_requests_total[5m])) by (service)"\n          }\n        ],\n        "type": "graph"\n      },\n      {\n        "title": "Error Rate",\n        "targets": [\n          {\n            "expr": "sum(rate(http_requests_total{status_code=~\\"5..\\"}[5m])) by (service) / sum(rate(http_requests_total[5m])) by (service)"\n          }\n        ],\n        "type": "graph"\n      },\n      {\n        "title": "P95 Latency",\n        "targets": [\n          {\n            "expr": "histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[5m])) by (service, le))"\n          }\n        ],\n        "type": "graph"\n      },\n      {\n        "title": "Active Orders",\n        "targets": [\n          {\n            "expr": "sum(orders_total{status=\\"pending\\"}) by (organization_id)"\n          }\n        ],\n        "type": "stat"\n      }\n    ]\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"dashboard-de-order-service",children:"Dashboard de Order Service"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "dashboard": {\n    "title": "Order Service Metrics",\n    "panels": [\n      {\n        "title": "Orders by Status",\n        "targets": [\n          {\n            "expr": "sum(orders_total) by (status)"\n          }\n        ],\n        "type": "piechart"\n      },\n      {\n        "title": "Order Value Distribution",\n        "targets": [\n          {\n            "expr": "histogram_quantile(0.50, sum(rate(order_value_dollars_bucket[1h])) by (le))",\n            "legendFormat": "P50"\n          },\n          {\n            "expr": "histogram_quantile(0.95, sum(rate(order_value_dollars_bucket[1h])) by (le))",\n            "legendFormat": "P95"\n          }\n        ],\n        "type": "graph"\n      },\n      {\n        "title": "Event Processing Time",\n        "targets": [\n          {\n            "expr": "rate(event_processing_duration_seconds_sum[5m]) / rate(event_processing_duration_seconds_count[5m])"\n          }\n        ],\n        "type": "graph"\n      }\n    ]\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"pr\xf3ximos-pasos",children:"Pr\xf3ximos Pasos"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"/observabilidad/error-handling",children:"Manejo de Errores"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"/observabilidad/alerting",children:"Alerting Strategy"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"/observabilidad/log-aggregation",children:"Log Aggregation"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var r=t(6540);const a={},s=r.createContext(a);function i(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);