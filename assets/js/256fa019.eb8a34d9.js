"use strict";(globalThis.webpackChunkerp_docs=globalThis.webpackChunkerp_docs||[]).push([[7213],{5765:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"microservicios/inventory-service/arquitectura","title":"Arquitectura","description":"Arquitectura t\xe9cnica completa del Inventory Service con diagramas de componentes, patrones y decisiones de dise\xf1o.","source":"@site/docs/02-microservicios/inventory-service/02-arquitectura.md","sourceDirName":"02-microservicios/inventory-service","slug":"/microservicios/inventory-service/arquitectura","permalink":"/zenlogic/microservicios/inventory-service/arquitectura","draft":false,"unlisted":false,"editUrl":"https://github.com/your-repo/edit/main/docs/02-microservicios/inventory-service/02-arquitectura.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docs","previous":{"title":"Inventory Service - Overview","permalink":"/zenlogic/microservicios/inventory-service/overview"},"next":{"title":"Modelo de Datos","permalink":"/zenlogic/microservicios/inventory-service/modelo-datos"}}');var r=t(4848),a=t(8453);const s={sidebar_position:2},o="Arquitectura",l={},c=[{value:"Arquitectura General",id:"arquitectura-general",level:2},{value:"Componentes Principales",id:"componentes-principales",level:2},{value:"1. API Layer",id:"1-api-layer",level:3},{value:"REST API (FastAPI)",id:"rest-api-fastapi",level:4},{value:"gRPC Server",id:"grpc-server",level:4},{value:"2. Application Layer",id:"2-application-layer",level:3},{value:"Stock Service",id:"stock-service",level:4},{value:"Reservation Service",id:"reservation-service",level:4},{value:"3. Domain Layer",id:"3-domain-layer",level:3},{value:"Modelos de Dominio",id:"modelos-de-dominio",level:4},{value:"4. Infrastructure Layer",id:"4-infrastructure-layer",level:3},{value:"Database (PostgreSQL)",id:"database-postgresql",level:4},{value:"Cache (Redis)",id:"cache-redis",level:4},{value:"Message Broker (RabbitMQ)",id:"message-broker-rabbitmq",level:4},{value:"Patrones de Dise\xf1o",id:"patrones-de-dise\xf1o",level:2},{value:"1. Repository Pattern",id:"1-repository-pattern",level:3},{value:"2. Unit of Work Pattern",id:"2-unit-of-work-pattern",level:3},{value:"3. Saga Pattern (Distributed Transactions)",id:"3-saga-pattern-distributed-transactions",level:3},{value:"Pr\xf3ximos Pasos",id:"pr\xf3ximos-pasos",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"arquitectura",children:"Arquitectura"})}),"\n",(0,r.jsx)(n.p,{children:"Arquitectura t\xe9cnica completa del Inventory Service con diagramas de componentes, patrones y decisiones de dise\xf1o."}),"\n",(0,r.jsx)(n.h2,{id:"arquitectura-general",children:"Arquitectura General"}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n    subgraph "API Layer"\n        REST[REST API<br/>FastAPI<br/>Port 8003]\n        GRPC[gRPC Server<br/>Port 50053]\n    end\n\n    subgraph "Application Layer"\n        STOCK_SVC[Stock Service]\n        MOVEMENT_SVC[Movement Service]\n        TRANSFER_SVC[Transfer Service]\n        ADJUSTMENT_SVC[Adjustment Service]\n        RESERVATION_SVC[Reservation Service]\n    end\n\n    subgraph "Domain Layer"\n        STOCK_MODEL[Stock Model]\n        MOVEMENT_MODEL[Movement Model]\n        TRANSFER_MODEL[Transfer Model]\n        WAREHOUSE_MODEL[Warehouse Model]\n        LOCATION_MODEL[Location Model]\n    end\n\n    subgraph "Infrastructure Layer"\n        DB[(PostgreSQL<br/>Database)]\n        CACHE[(Redis<br/>Cache)]\n        MQ[RabbitMQ<br/>Message Broker]\n        GRPC_CLIENTS[gRPC Clients<br/>Catalog/Order]\n    end\n\n    REST --\x3e STOCK_SVC\n    REST --\x3e MOVEMENT_SVC\n    REST --\x3e TRANSFER_SVC\n    REST --\x3e ADJUSTMENT_SVC\n    GRPC --\x3e STOCK_SVC\n    GRPC --\x3e RESERVATION_SVC\n\n    STOCK_SVC --\x3e STOCK_MODEL\n    MOVEMENT_SVC --\x3e MOVEMENT_MODEL\n    TRANSFER_SVC --\x3e TRANSFER_MODEL\n\n    STOCK_MODEL --\x3e DB\n    STOCK_SVC --\x3e CACHE\n    STOCK_SVC --\x3e MQ\n    STOCK_SVC --\x3e GRPC_CLIENTS'}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"componentes-principales",children:"Componentes Principales"}),"\n",(0,r.jsx)(n.h3,{id:"1-api-layer",children:"1. API Layer"}),"\n",(0,r.jsx)(n.h4,{id:"rest-api-fastapi",children:"REST API (FastAPI)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Puerto:"})," ",(0,r.jsx)(n.code,{children:"8003"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# main.py\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.middleware.gzip import GZipMiddleware\n\napp = FastAPI(\n    title="Inventory Service API",\n    version="1.0.0",\n    docs_url="/docs",\n    redoc_url="/redoc"\n)\n\n# Middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\napp.add_middleware(GZipMiddleware, minimum_size=1000)\n\n# Routers\napp.include_router(stock_router, prefix="/api/v1/stock", tags=["Stock"])\napp.include_router(movement_router, prefix="/api/v1/movements", tags=["Movements"])\napp.include_router(warehouse_router, prefix="/api/v1/warehouses", tags=["Warehouses"])\napp.include_router(transfer_router, prefix="/api/v1/transfers", tags=["Transfers"])\napp.include_router(adjustment_router, prefix="/api/v1/adjustments", tags=["Adjustments"])\napp.include_router(location_router, prefix="/api/v1/locations", tags=["Locations"])\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Rutas Principales:"})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Prefijo"}),(0,r.jsx)(n.th,{children:"Descripci\xf3n"}),(0,r.jsx)(n.th,{children:"Endpoints"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/api/v1/stock"})}),(0,r.jsx)(n.td,{children:"Gesti\xf3n de stock"}),(0,r.jsx)(n.td,{children:"7 endpoints"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/api/v1/movements"})}),(0,r.jsx)(n.td,{children:"Movimientos de inventario"}),(0,r.jsx)(n.td,{children:"8 endpoints"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/api/v1/warehouses"})}),(0,r.jsx)(n.td,{children:"Administraci\xf3n de bodegas"}),(0,r.jsx)(n.td,{children:"7 endpoints"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/api/v1/transfers"})}),(0,r.jsx)(n.td,{children:"Transferencias entre bodegas"}),(0,r.jsx)(n.td,{children:"7 endpoints"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/api/v1/adjustments"})}),(0,r.jsx)(n.td,{children:"Ajustes de inventario"}),(0,r.jsx)(n.td,{children:"6 endpoints"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/api/v1/locations"})}),(0,r.jsx)(n.td,{children:"Ubicaciones f\xedsicas"}),(0,r.jsx)(n.td,{children:"5 endpoints"})]})]})]}),"\n",(0,r.jsx)(n.h4,{id:"grpc-server",children:"gRPC Server"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Puerto:"})," ",(0,r.jsx)(n.code,{children:"50053"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-protobuf",children:'// inventory.proto\nsyntax = "proto3";\n\npackage inventory;\n\nservice InventoryService {\n  // Stock operations\n  rpc CheckAvailability(AvailabilityRequest) returns (AvailabilityResponse);\n  rpc ReserveStock(ReserveStockRequest) returns (ReserveStockResponse);\n  rpc ReleaseReservation(ReleaseRequest) returns (ReleaseResponse);\n  rpc ConfirmReservation(ConfirmRequest) returns (ConfirmResponse);\n\n  // Warehouse operations\n  rpc GetWarehouseStock(WarehouseRequest) returns (WarehouseStockResponse);\n\n  // Movement operations\n  rpc GetStockHistory(HistoryRequest) returns (HistoryResponse);\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Implementaci\xf3n:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# grpc_server.py\nfrom concurrent import futures\nimport grpc\nfrom proto import inventory_pb2_grpc\n\nclass InventoryServicer(inventory_pb2_grpc.InventoryServiceServicer):\n    def __init__(self, stock_service, reservation_service):\n        self.stock_service = stock_service\n        self.reservation_service = reservation_service\n\n    async def CheckAvailability(self, request, context):\n        # Implementation\n        pass\n\n    async def ReserveStock(self, request, context):\n        # Implementation\n        pass\n\nasync def serve():\n    server = grpc.aio.server(\n        futures.ThreadPoolExecutor(max_workers=10)\n    )\n\n    inventory_pb2_grpc.add_InventoryServiceServicer_to_server(\n        InventoryServicer(stock_service, reservation_service),\n        server\n    )\n\n    server.add_insecure_port('[::]:50053')\n    await server.start()\n    await server.wait_for_termination()\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"2-application-layer",children:"2. Application Layer"}),"\n",(0,r.jsx)(n.h4,{id:"stock-service",children:"Stock Service"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Responsabilidades:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Gesti\xf3n de niveles de stock"}),"\n",(0,r.jsx)(n.li,{children:"Validaciones de disponibilidad"}),"\n",(0,r.jsx)(n.li,{children:"Alertas de stock bajo"}),"\n",(0,r.jsx)(n.li,{children:"Sincronizaci\xf3n con cache"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# services/stock_service.py\nfrom typing import Optional, List, Dict, Any\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom redis.asyncio import Redis\n\nclass StockService:\n    def __init__(self, db: AsyncSession, redis: Redis):\n        self.db = db\n        self.redis = redis\n\n    async def get_stock(\n        self,\n        variant_id: str,\n        warehouse_id: str,\n        organization_id: str\n    ) -> Optional[Stock]:\n        \"\"\"Get stock with cache fallback.\"\"\"\n        # Try cache first\n        cache_key = f\"stock:{variant_id}:{warehouse_id}\"\n        cached = await self.redis.get(cache_key)\n\n        if cached:\n            return Stock.parse_raw(cached)\n\n        # Query database\n        stock = await self.db.execute(\n            select(Stock).where(\n                Stock.variant_id == variant_id,\n                Stock.warehouse_id == warehouse_id,\n                Stock.organization_id == organization_id\n            )\n        )\n\n        result = stock.scalar_one_or_none()\n\n        if result:\n            # Cache for 1 minute\n            await self.redis.setex(\n                cache_key,\n                60,\n                result.json()\n            )\n\n        return result\n\n    async def check_availability(\n        self,\n        variant_id: str,\n        quantity: int,\n        organization_id: str,\n        preferred_warehouse_id: Optional[str] = None\n    ) -> Dict[str, Any]:\n        \"\"\"Check if sufficient stock is available.\"\"\"\n        if preferred_warehouse_id:\n            stock = await self.get_stock(\n                variant_id,\n                preferred_warehouse_id,\n                organization_id\n            )\n\n            if stock and stock.available_quantity >= quantity:\n                return {\n                    'available': True,\n                    'warehouse_id': preferred_warehouse_id,\n                    'available_quantity': stock.available_quantity\n                }\n\n        # Find warehouse with most available stock\n        stocks = await self.db.execute(\n            select(Stock)\n            .where(\n                Stock.variant_id == variant_id,\n                Stock.organization_id == organization_id,\n                Stock.available_quantity >= quantity\n            )\n            .order_by(Stock.available_quantity.desc())\n        )\n\n        best_stock = stocks.scalars().first()\n\n        if best_stock:\n            return {\n                'available': True,\n                'warehouse_id': best_stock.warehouse_id,\n                'available_quantity': best_stock.available_quantity\n            }\n\n        return {'available': False}\n\n    async def update_stock_quantities(\n        self,\n        stock_id: str,\n        quantity_change: int,\n        movement_type: str,\n        expected_version: Optional[int] = None\n    ) -> Stock:\n        \"\"\"Update stock with optimistic locking.\"\"\"\n        query = (\n            update(Stock)\n            .where(Stock.stock_id == stock_id)\n            .values(\n                total_quantity=Stock.total_quantity + quantity_change,\n                version=Stock.version + 1,\n                updated_at=datetime.utcnow()\n            )\n            .returning(Stock)\n        )\n\n        if expected_version is not None:\n            query = query.where(Stock.version == expected_version)\n\n        result = await self.db.execute(query)\n        stock = result.scalar_one_or_none()\n\n        if not stock:\n            raise ConcurrentModificationError(\n                f\"Stock {stock_id} was modified\"\n            )\n\n        # Invalidate cache\n        await self.invalidate_stock_cache(stock)\n\n        # Check for low stock\n        await self.check_low_stock_alert(stock)\n\n        return stock\n\n    async def check_low_stock_alert(self, stock: Stock) -> None:\n        \"\"\"Check and publish low stock alerts.\"\"\"\n        if stock.available_quantity <= stock.min_stock:\n            alert_level = 'critical' if stock.available_quantity == 0 else 'warning'\n\n            await event_publisher.publish('inventory.stock.low_level', {\n                'stock_id': stock.stock_id,\n                'variant_id': stock.variant_id,\n                'warehouse_id': stock.warehouse_id,\n                'available_quantity': stock.available_quantity,\n                'min_stock': stock.min_stock,\n                'alert_level': alert_level\n            })\n"})}),"\n",(0,r.jsx)(n.h4,{id:"reservation-service",children:"Reservation Service"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Responsabilidades:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Crear/liberar reservas"}),"\n",(0,r.jsx)(n.li,{children:"Gesti\xf3n de TTL autom\xe1tico"}),"\n",(0,r.jsx)(n.li,{children:"Confirmaci\xf3n de reservas"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# services/reservation_service.py\nfrom datetime import datetime, timedelta\n\nclass ReservationService:\n    def __init__(self, db: AsyncSession, scheduler: Scheduler):\n        self.db = db\n        self.scheduler = scheduler\n\n    async def create_reservation(\n        self,\n        order_id: str,\n        organization_id: str,\n        items: List[Dict[str, Any]],\n        ttl_minutes: int = 15\n    ) -> Reservation:\n        \"\"\"Create stock reservation with auto-expiry.\"\"\"\n        reservation_id = generate_uuid()\n        expires_at = datetime.utcnow() + timedelta(minutes=ttl_minutes)\n\n        # Validate all items have stock\n        for item in items:\n            stock = await stock_service.get_stock(\n                variant_id=item['variant_id'],\n                warehouse_id=item['warehouse_id'],\n                organization_id=organization_id\n            )\n\n            if not stock or stock.available_quantity < item['quantity']:\n                raise InsufficientStockError(\n                    f\"Insufficient stock for {item['variant_id']}\"\n                )\n\n        # Create reservation\n        reservation = Reservation(\n            reservation_id=reservation_id,\n            order_id=order_id,\n            organization_id=organization_id,\n            items=items,\n            status='active',\n            expires_at=expires_at\n        )\n\n        self.db.add(reservation)\n\n        # Update stock quantities (available -> reserved)\n        for item in items:\n            await stock_service.reserve_quantity(\n                variant_id=item['variant_id'],\n                warehouse_id=item['warehouse_id'],\n                quantity=item['quantity']\n            )\n\n        await self.db.commit()\n\n        # Schedule auto-release\n        await self.scheduler.schedule_task(\n            task='release_expired_reservation',\n            execute_at=expires_at,\n            args={'reservation_id': reservation_id}\n        )\n\n        return reservation\n\n    async def release_reservation(\n        self,\n        reservation_id: str,\n        reason: str = 'manual_release'\n    ) -> None:\n        \"\"\"Release reserved stock.\"\"\"\n        reservation = await self.get_reservation(reservation_id)\n\n        if reservation.status != 'active':\n            raise InvalidReservationStateError(\n                f\"Cannot release reservation with status {reservation.status}\"\n            )\n\n        # Update stock (reserved -> available)\n        for item in reservation.items:\n            await stock_service.release_quantity(\n                variant_id=item['variant_id'],\n                warehouse_id=item['warehouse_id'],\n                quantity=item['quantity']\n            )\n\n        # Update reservation status\n        reservation.status = 'released'\n        reservation.released_at = datetime.utcnow()\n        reservation.release_reason = reason\n\n        await self.db.commit()\n\n        # Cancel scheduled auto-release\n        await self.scheduler.cancel_task(\n            task='release_expired_reservation',\n            args={'reservation_id': reservation_id}\n        )\n\n        # Publish event\n        await event_publisher.publish('inventory.stock.released', {\n            'reservation_id': reservation_id,\n            'order_id': reservation.order_id,\n            'reason': reason\n        })\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"3-domain-layer",children:"3. Domain Layer"}),"\n",(0,r.jsx)(n.h4,{id:"modelos-de-dominio",children:"Modelos de Dominio"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# models/stock.py\nfrom sqlalchemy import Column, String, Integer, DECIMAL, DateTime, Index\nfrom sqlalchemy.dialects.postgresql import UUID, JSONB\nimport uuid\n\nclass Stock(Base):\n    __tablename__ = 'stock'\n\n    stock_id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    organization_id = Column(UUID(as_uuid=True), nullable=False)\n    variant_id = Column(UUID(as_uuid=True), nullable=False)\n    warehouse_id = Column(UUID(as_uuid=True), nullable=False)\n\n    # Quantities\n    total_quantity = Column(Integer, nullable=False, default=0)\n    available_quantity = Column(Integer, nullable=False, default=0)\n    reserved_quantity = Column(Integer, nullable=False, default=0)\n    damaged_quantity = Column(Integer, nullable=False, default=0)\n    in_transit_quantity = Column(Integer, nullable=False, default=0)\n\n    # Thresholds\n    min_stock = Column(Integer, nullable=False, default=0)\n    max_stock = Column(Integer, nullable=False, default=999999)\n    reorder_point = Column(Integer, nullable=False, default=0)\n\n    # Configuration\n    stock_strategy = Column(String(10), nullable=False, default='FIFO')\n    track_lots = Column(Boolean, default=False)\n    track_serial_numbers = Column(Boolean, default=False)\n\n    # Metadata\n    version = Column(Integer, nullable=False, default=1)\n    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)\n    updated_at = Column(DateTime, onupdate=datetime.utcnow)\n\n    # Indexes\n    __table_args__ = (\n        Index('idx_stock_variant_warehouse', 'variant_id', 'warehouse_id'),\n        Index('idx_stock_organization', 'organization_id'),\n        Index('idx_stock_low_level', 'available_quantity', 'min_stock'),\n        # Constraint\n        CheckConstraint(\n            'total_quantity = available_quantity + reserved_quantity + damaged_quantity + in_transit_quantity',\n            name='check_stock_quantities'\n        ),\n        # Unique constraint\n        UniqueConstraint('variant_id', 'warehouse_id', 'organization_id', name='uq_stock_variant_warehouse'),\n    )\n\n    @property\n    def is_low_stock(self) -> bool:\n        \"\"\"Check if stock is below minimum.\"\"\"\n        return self.available_quantity <= self.min_stock\n\n    @property\n    def needs_reorder(self) -> bool:\n        \"\"\"Check if stock reached reorder point.\"\"\"\n        return self.available_quantity <= self.reorder_point\n\n    @property\n    def utilization_percentage(self) -> float:\n        \"\"\"Calculate stock utilization.\"\"\"\n        if self.max_stock == 0:\n            return 0.0\n        return (self.total_quantity / self.max_stock) * 100\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"4-infrastructure-layer",children:"4. Infrastructure Layer"}),"\n",(0,r.jsx)(n.h4,{id:"database-postgresql",children:"Database (PostgreSQL)"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Configuraci\xf3n:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# database.py\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession\nfrom sqlalchemy.orm import sessionmaker\n\nDATABASE_URL = "postgresql+asyncpg://user:pass@localhost:5432/inventory_db"\n\nengine = create_async_engine(\n    DATABASE_URL,\n    echo=False,\n    pool_size=20,\n    max_overflow=40,\n    pool_pre_ping=True,\n    pool_recycle=3600\n)\n\nAsyncSessionLocal = sessionmaker(\n    engine,\n    class_=AsyncSession,\n    expire_on_commit=False\n)\n\nasync def get_db() -> AsyncSession:\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n        finally:\n            await session.close()\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Row-Level Security:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"-- Enable RLS on all tables\nALTER TABLE stock ENABLE ROW LEVEL SECURITY;\nALTER TABLE stock_movement ENABLE ROW LEVEL SECURITY;\nALTER TABLE warehouse ENABLE ROW LEVEL SECURITY;\nALTER TABLE stock_transfer ENABLE ROW LEVEL SECURITY;\n\n-- Create policy for organization isolation\nCREATE POLICY stock_organization_isolation ON stock\n    USING (organization_id = current_setting('app.current_organization_id')::uuid);\n\nCREATE POLICY movement_organization_isolation ON stock_movement\n    USING (organization_id = current_setting('app.current_organization_id')::uuid);\n\n-- Set organization_id for each request\nSET app.current_organization_id = 'org_123';\n"})}),"\n",(0,r.jsx)(n.h4,{id:"cache-redis",children:"Cache (Redis)"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Estrategia de Cache:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# cache/redis_client.py\nimport redis.asyncio as redis\nfrom typing import Optional, Any\nimport json\n\nclass RedisCache:\n    def __init__(self, url: str):\n        self.client = redis.from_url(\n            url,\n            decode_responses=True,\n            encoding='utf-8'\n        )\n\n    async def get(self, key: str) -> Optional[Any]:\n        \"\"\"Get value from cache.\"\"\"\n        value = await self.client.get(key)\n        if value:\n            return json.loads(value)\n        return None\n\n    async def set(\n        self,\n        key: str,\n        value: Any,\n        ttl: int = 60\n    ) -> None:\n        \"\"\"Set value in cache with TTL.\"\"\"\n        await self.client.setex(\n            key,\n            ttl,\n            json.dumps(value, default=str)\n        )\n\n    async def delete(self, key: str) -> None:\n        \"\"\"Delete key from cache.\"\"\"\n        await self.client.delete(key)\n\n    async def delete_pattern(self, pattern: str) -> None:\n        \"\"\"Delete all keys matching pattern.\"\"\"\n        keys = await self.client.keys(pattern)\n        if keys:\n            await self.client.delete(*keys)\n\n# Cache keys\nCACHE_KEYS = {\n    'stock': 'stock:{variant_id}:{warehouse_id}',\n    'warehouse': 'warehouse:{warehouse_id}',\n    'variant': 'variant:{variant_id}',\n    'stock_by_variant': 'stock:variant:{variant_id}',\n}\n\n# TTL configuration\nCACHE_TTL = {\n    'stock': 60,          # 1 minute\n    'warehouse': 3600,    # 1 hour\n    'variant': 1800,      # 30 minutes\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"message-broker-rabbitmq",children:"Message Broker (RabbitMQ)"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Publisher:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# events/publisher.py\nimport aio_pika\nfrom typing import Dict, Any\nimport json\n\nclass EventPublisher:\n    def __init__(self, rabbitmq_url: str):\n        self.url = rabbitmq_url\n        self.connection = None\n        self.channel = None\n\n    async def connect(self):\n        """Establish connection to RabbitMQ."""\n        self.connection = await aio_pika.connect_robust(self.url)\n        self.channel = await self.connection.channel()\n\n        # Declare exchange\n        self.exchange = await self.channel.declare_exchange(\n            \'inventory_events\',\n            aio_pika.ExchangeType.TOPIC,\n            durable=True\n        )\n\n    async def publish(\n        self,\n        event_type: str,\n        data: Dict[str, Any],\n        organization_id: str\n    ) -> None:\n        """Publish event to RabbitMQ."""\n        event = {\n            \'event\': event_type,\n            \'version\': \'1.0\',\n            \'timestamp\': datetime.utcnow().isoformat(),\n            \'organization_id\': organization_id,\n            \'event_id\': str(uuid.uuid4()),\n            \'data\': data\n        }\n\n        message = aio_pika.Message(\n            body=json.dumps(event).encode(),\n            content_type=\'application/json\',\n            delivery_mode=aio_pika.DeliveryMode.PERSISTENT\n        )\n\n        await self.exchange.publish(\n            message,\n            routing_key=event_type\n        )\n\n        logger.info(f"Published event: {event_type}")\n\n    async def close(self):\n        """Close connection."""\n        if self.connection:\n            await self.connection.close()\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Consumer:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# events/consumer.py\nclass EventConsumer:\n    def __init__(self, rabbitmq_url: str):\n        self.url = rabbitmq_url\n        self.handlers = {}\n\n    def register_handler(self, event_type: str, handler):\n        """Register event handler."""\n        self.handlers[event_type] = handler\n\n    async def start(self):\n        """Start consuming events."""\n        connection = await aio_pika.connect_robust(self.url)\n        channel = await connection.channel()\n\n        await channel.set_qos(prefetch_count=10)\n\n        # Declare queue\n        queue = await channel.declare_queue(\n            \'inventory_catalog_consumer\',\n            durable=True\n        )\n\n        # Bind to routing keys\n        exchange = await channel.declare_exchange(\n            \'catalog_events\',\n            aio_pika.ExchangeType.TOPIC\n        )\n\n        await queue.bind(exchange, \'catalog.variant.created\')\n        await queue.bind(exchange, \'catalog.variant.deleted\')\n\n        # Start consuming\n        async with queue.iterator() as queue_iter:\n            async for message in queue_iter:\n                async with message.process():\n                    event = json.loads(message.body)\n                    event_type = event[\'event\']\n\n                    if event_type in self.handlers:\n                        try:\n                            await self.handlers[event_type](event)\n                        except Exception as e:\n                            logger.error(f"Error handling {event_type}: {e}")\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"patrones-de-dise\xf1o",children:"Patrones de Dise\xf1o"}),"\n",(0,r.jsx)(n.h3,{id:"1-repository-pattern",children:"1. Repository Pattern"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# repositories/stock_repository.py\nfrom typing import List, Optional\nfrom sqlalchemy import select\n\nclass StockRepository:\n    def __init__(self, db: AsyncSession):\n        self.db = db\n\n    async def get_by_id(self, stock_id: str) -> Optional[Stock]:\n        result = await self.db.execute(\n            select(Stock).where(Stock.stock_id == stock_id)\n        )\n        return result.scalar_one_or_none()\n\n    async def get_by_variant_warehouse(\n        self,\n        variant_id: str,\n        warehouse_id: str,\n        organization_id: str\n    ) -> Optional[Stock]:\n        result = await self.db.execute(\n            select(Stock).where(\n                Stock.variant_id == variant_id,\n                Stock.warehouse_id == warehouse_id,\n                Stock.organization_id == organization_id\n            )\n        )\n        return result.scalar_one_or_none()\n\n    async def get_low_stock_items(\n        self,\n        organization_id: str,\n        warehouse_id: Optional[str] = None\n    ) -> List[Stock]:\n        query = select(Stock).where(\n            Stock.organization_id == organization_id,\n            Stock.available_quantity <= Stock.min_stock\n        )\n\n        if warehouse_id:\n            query = query.where(Stock.warehouse_id == warehouse_id)\n\n        result = await self.db.execute(query)\n        return result.scalars().all()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-unit-of-work-pattern",children:"2. Unit of Work Pattern"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Unit of Work implementation\nclass UnitOfWork:\n    def __init__(self, db: AsyncSession):\n        self.db = db\n        self.stock_repo = StockRepository(db)\n        self.movement_repo = MovementRepository(db)\n        self.transfer_repo = TransferRepository(db)\n\n    async def commit(self):\n        await self.db.commit()\n\n    async def rollback(self):\n        await self.db.rollback()\n\n    async def __aenter__(self):\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if exc_type:\n            await self.rollback()\n        await self.db.close()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-saga-pattern-distributed-transactions",children:"3. Saga Pattern (Distributed Transactions)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# saga/transfer_saga.py\nclass TransferSaga:\n    """Saga for warehouse transfer with compensating actions."""\n\n    def __init__(self, uow: UnitOfWork):\n        self.uow = uow\n        self.completed_steps = []\n\n    async def execute_transfer(self, transfer_id: str):\n        try:\n            # Step 1: Reserve stock in origin\n            await self.reserve_stock_origin(transfer_id)\n            self.completed_steps.append(\'reserve\')\n\n            # Step 2: Update transfer status\n            await self.mark_in_transit(transfer_id)\n            self.completed_steps.append(\'in_transit\')\n\n            # Step 3: Receive in destination\n            await self.receive_stock_destination(transfer_id)\n            self.completed_steps.append(\'receive\')\n\n            # Step 4: Commit\n            await self.uow.commit()\n\n        except Exception as e:\n            await self.compensate(transfer_id)\n            raise\n\n    async def compensate(self, transfer_id: str):\n        """Rollback completed steps in reverse order."""\n        for step in reversed(self.completed_steps):\n            if step == \'reserve\':\n                await self.release_reservation(transfer_id)\n            elif step == \'in_transit\':\n                await self.cancel_transfer(transfer_id)\n            # Add more compensating actions\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"pr\xf3ximos-pasos",children:"Pr\xf3ximos Pasos"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"./modelo-datos",children:"Modelo de Datos"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"./api-stock",children:"API: Stock"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"./eventos-publicados",children:"Eventos Publicados"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var i=t(6540);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);